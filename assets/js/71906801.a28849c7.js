"use strict";(self.webpackChunkshawntabrizi=self.webpackChunkshawntabrizi||[]).push([[7087],{61047:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>n,metadata:()=>o,toc:()=>c});var r=a(85893),i=a(11151);const n={title:"Programmatically fetch multiple APIs in parallel using async and await in JavaScript",date:new Date("2017-12-09T11:13:44.000Z"),authors:"shawntabrizi",layout:"post",slug:"/code/programmatically-fetch-multiple-apis-parallel-using-async-await-javascript/",categories:["Code"],tags:["async","fetch","javascript"]},s=void 0,o={permalink:"/blog/code/programmatically-fetch-multiple-apis-parallel-using-async-await-javascript/",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2017-12-09-programmatically-fetch-multiple-apis-parallel-using-async-await-javascript.md",source:"@site/blog/2017-12-09-programmatically-fetch-multiple-apis-parallel-using-async-await-javascript.md",title:"Programmatically fetch multiple APIs in parallel using async and await in JavaScript",description:"When I was building ethfolio, I had to figure out how to retrieve the token information for multiple Ethereum addresses. To get this information, you have to query an API per address that you want to retrieve.",date:"2017-12-09T11:13:44.000Z",formattedDate:"December 9, 2017",tags:[{label:"async",permalink:"/blog/tags/async"},{label:"fetch",permalink:"/blog/tags/fetch"},{label:"javascript",permalink:"/blog/tags/javascript"}],readingTime:1.225,hasTruncateMarker:!1,authors:[{name:"Shawn Tabrizi",title:"Software Engineer",url:"https://github.com/shawntabrizi",imageURL:"https://github.com/shawntabrizi.png",key:"shawntabrizi"}],frontMatter:{title:"Programmatically fetch multiple APIs in parallel using async and await in JavaScript",date:"2017-12-09T11:13:44.000Z",authors:"shawntabrizi",layout:"post",slug:"/code/programmatically-fetch-multiple-apis-parallel-using-async-await-javascript/",categories:["Code"],tags:["async","fetch","javascript"]},unlisted:!1,prevItem:{title:"Set up Azure Service Health Alerts programmatically using PowerShell",permalink:"/blog/code/set-azure-service-health-alerts-programmatically-using-powershell/"},nextItem:{title:"ethfolio: A client side app to show your Ethereum token distribution",permalink:"/blog/ethereum/ethfolio-client-side-app-show-ethereum-token-distribution/"}},l={authorsImageUrls:[void 0]},c=[];function h(e){const t={a:"a",code:"code",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["When I was building ",(0,r.jsx)(t.a,{href:"https://shawntabrizi.com/ethfolio/",children:"ethfolio"}),", I had to figure out how to retrieve the token information for multiple Ethereum addresses. To get this information, you have to query an API per address that you want to retrieve."]}),"\n",(0,r.jsx)(t.p,{children:"Ideally, all of these calls would happen Asynchronously and in parallel, to give the  best and fastest experience to the user. However, how exactly to do this is not so obvious (to me at least)."}),"\n",(0,r.jsx)(t.p,{children:"Let's assume that you have an array of URLs that you want to fetch at the same time. You can use an asynchronous function like this to easily retrieve all the data in the best way possible:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"async function getAllUrls(urls) {\n    try {\n        var data = await Promise.all(\n            urls.map(\n                url =>\n                    fetch(url).then(\n                        (response) => response.json()\n                    )));\n\n        return (data)\n\n    } catch (error) {\n        console.log(error)\n\n        throw (error)\n    }\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"This function will return an array of 'responses' which you can then use for the rest of your program. Calling the function is simple too!"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"var responses = await getAllUrls(urls)\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Ultimately the trick here is that a ",(0,r.jsx)(t.code,{children:"Promise"})," gets executed as soon as it gets created. The ",(0,r.jsx)(t.code,{children:"map"})," function will create all the ",(0,r.jsx)(t.code,{children:"fetch"})," promises and they will immediately start to execute. Then, we wait for all the promises to complete using the ",(0,r.jsx)(t.code,{children:"Promise.all"})," function."]}),"\n",(0,r.jsx)(t.p,{children:"I tried other ways to construct this kind of function, but none were quite as simple or effective as this. I hope you find this helpful :)"})]})}function u(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},11151:(e,t,a)=>{a.d(t,{Z:()=>o,a:()=>s});var r=a(67294);const i={},n=r.createContext(i);function s(e){const t=r.useContext(n);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(n.Provider,{value:t},e.children)}}}]);