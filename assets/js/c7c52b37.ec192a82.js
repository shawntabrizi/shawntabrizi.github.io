"use strict";(self.webpackChunkshawntabrizi=self.webpackChunkshawntabrizi||[]).push([[14151],{50815:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var i=n(85893),s=n(11151);const o={title:"Proof of Existence Blockchain with Substrate",date:new Date("2019-01-01T03:54:39.000Z"),authors:"shawntabrizi",slug:"/substrate/proof-of-existence-blockchain-with-substrate/",categories:["Substrate"],tags:["blockchain","programming","runtime","substrate"],github:"substrate-proof-of-existence"},a=void 0,r={permalink:"/blog/substrate/proof-of-existence-blockchain-with-substrate/",source:"@site/blog/2018-12-31-proof-of-existence-blockchain-with-substrate.md",title:"Proof of Existence Blockchain with Substrate",description:"This post will show you how easy it is to build a proof of existence blockchain with a user interface using Parity's Substrate framework.",date:"2019-01-01T03:54:39.000Z",formattedDate:"January 1, 2019",tags:[{label:"blockchain",permalink:"/blog/tags/blockchain"},{label:"programming",permalink:"/blog/tags/programming"},{label:"runtime",permalink:"/blog/tags/runtime"},{label:"substrate",permalink:"/blog/tags/substrate"}],readingTime:8.955,hasTruncateMarker:!1,authors:[{name:"Shawn Tabrizi",title:"Software Engineer",url:"https://github.com/shawntabrizi",imageURL:"https://github.com/shawntabrizi.png",key:"shawntabrizi"}],frontMatter:{title:"Proof of Existence Blockchain with Substrate",date:"2019-01-01T03:54:39.000Z",authors:"shawntabrizi",slug:"/substrate/proof-of-existence-blockchain-with-substrate/",categories:["Substrate"],tags:["blockchain","programming","runtime","substrate"],github:"substrate-proof-of-existence"},unlisted:!1,prevItem:{title:"CryptoKitties on Substrate",permalink:"/blog/substrate/cryptokitties-on-substrate/"},nextItem:{title:"Verify Ethereum Contracts Using Web3.js and Solc",permalink:"/blog/ethereum/verify-ethereum-contracts-using-web3-js-and-solc/"}},c={authorsImageUrls:[void 0]},l=[{value:"This post will show you how easy it is to build a proof of existence blockchain with a user interface using Parity&#39;s Substrate framework.",id:"this-post-will-show-you-how-easy-it-is-to-build-a-proof-of-existence-blockchain-with-a-user-interface-using-paritys-substrate-framework",level:5},{value:"Running a Substrate Chain",id:"running-a-substrate-chain",level:2},{value:"Developing the Proof of Existence Runtime Logic",id:"developing-the-proof-of-existence-runtime-logic",level:2},{value:"A Closer Look",id:"a-closer-look",level:3},{value:"Creating a User Interface for Our Chain",id:"creating-a-user-interface-for-our-chain",level:2},{value:"Custom Components",id:"custom-components",level:3},{value:"Final Thoughts and Next Steps",id:"final-thoughts-and-next-steps",level:2}];function h(e){const t={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h5:"h5",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h5,{id:"this-post-will-show-you-how-easy-it-is-to-build-a-proof-of-existence-blockchain-with-a-user-interface-using-paritys-substrate-framework",children:"This post will show you how easy it is to build a proof of existence blockchain with a user interface using Parity's Substrate framework."}),"\n",(0,i.jsxs)(t.p,{children:["2019 will surely be remembered as an exciting year for blockchain development and decentralized applications. Just in time for the new year, Parity's Substrate was ",(0,i.jsx)(t.a,{href:"https://www.parity.io/substrate-has-arrived/",children:"officially released in beta"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["If you are unfamiliar with ",(0,i.jsx)(t.a,{href:"https://github.com/paritytech/substrate",children:"Substrate"}),", it is a development framework enabling users to easily build custom blockchains. Whereas blockchain development would normally require you to develop peer-to-peer networking, a database layer, a JSON RPC, consensus algorithms, and more, Substrate provides you with enterprise ready, battle-test software which you can customize for your needs."]}),"\n",(0,i.jsxs)(t.p,{children:["To illustrate the simplicity of developing on Substrate, I thought I would try to build one of a simplest practical blockchains that you can develop: ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Proof_of_Existence",children:"a proof of existence blockchain"}),"."]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"Proof of Existence is an online service that verifies the existence of computer files as of a specific time via timestamped transactions in the bitcoin blockchain."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:'The first proof of existence platform was built as a sort of "hack" on top of the Bitcoin network. At that time, it would be pretty impractical to build an entire blockchain platform for just this purpose, but with Substrate, not only is it practical, but it is actually easy!'}),"\n",(0,i.jsx)(t.p,{children:"You can find the repository for this ongoing project here:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://github.com/shawntabrizi/substrate-proof-of-existence",children:"https://github.com/shawntabrizi/substrate-proof-of-existence"})}),"\n",(0,i.jsx)(t.p,{children:"So let's jump right in!"}),"\n",(0,i.jsx)(t.h2,{id:"running-a-substrate-chain",children:"Running a Substrate Chain"}),"\n",(0,i.jsxs)(t.p,{children:["Out of the box, Substrate provides you with all the tools you need to run a blockchain. Along with the underlying infrastructure (networking, database, consensus, etc...), Substrate comes with a ",(0,i.jsx)(t.a,{href:"https://github.com/paritytech/substrate/tree/master/frame",children:"library of runtime modules"})," which give you the features and functionalities of modern blockchains:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Balances (tokens, transfers, etc...)"}),"\n",(0,i.jsx)(t.li,{children:"Democracy (stakeholder voting)"}),"\n",(0,i.jsx)(t.li,{children:"Contract (smart contract platform)"}),"\n",(0,i.jsx)(t.li,{children:"and more!"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Note that a 'runtime' is just logic that powers your blockchain. For example, the state transition function in ",(0,i.jsx)(t.a,{href:"https://github.com/ethereum/wiki/wiki/White-Paper#bitcoin-as-a-state-transition-system",children:"Bitcoin"})," or ",(0,i.jsx)(t.a,{href:"https://github.com/ethereum/wiki/wiki/White-Paper#ethereum-state-transition-function",children:"Ethereum"})," could be thought of as the runtimes of those blockchains. These modules, along with custom modules that you develop, can be put together on Substrate to build a custom blockchain."]}),"\n",(0,i.jsxs)(t.p,{children:["Parity provides a bare-bones ",(0,i.jsx)(t.a,{href:"https://github.com/shawntabrizi/substrate-package",children:"substrate node template"})," which integrates a few of these modules into an out-of-the-box working blockchain. This is ",(0,i.jsx)(t.a,{href:"https://substrate.readme.io/v1.0.0/docs/creating-a-custom-substrate-chain#section-prerequisites",children:"all I needed to do"})," to set up a running chain:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:'curl https://getsubstrate.io -sSf | bash\nsubstrate-node-new proof-of-existence "Shawn Tabrizi"\nsubstrate-ui-new proof-of-existence\n'})}),"\n",(0,i.jsxs)(t.p,{children:["You can then start the blockchain by going into the ",(0,i.jsx)("code",{children:"proof-of-existence"})," folder and running:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"./target/release/proof-of-existence --dev\n"})}),"\n",(0,i.jsxs)(t.p,{children:["And finally you can interact with this chain using the ",(0,i.jsx)("code",{children:"proof-of-existence-ui"})," by running:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"npm run dev\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"An image of the Substrate UI",src:n(89409).Z+"",width:"1624",height:"1176"})}),"\n",(0,i.jsx)(t.h2,{id:"developing-the-proof-of-existence-runtime-logic",children:"Developing the Proof of Existence Runtime Logic"}),"\n",(0,i.jsx)(t.p,{children:"Now that we have things running, we want to add our own runtime logic on top to create a proof of existence blockchain. Fortunately, the logic we need to build is pretty simple and straightforward. Essentially, we just need to maintain some storage on the blockchain which establishes:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"An owner"}),"\n",(0,i.jsxs)(t.li,{children:["A file hash (or ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/File_verification",children:"file digest"}),")"]}),"\n",(0,i.jsx)(t.li,{children:"The timestamp of the verification"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Then, we need to create a function which allows a user to write to this storage and claim a file if it has not already been claimed before. For additional user-friendliness, we can also add a function which allows the specific owner of a file to revoke their claim, so that someone else may claim the file in the future."}),"\n",(0,i.jsxs)(t.p,{children:["Continuing to follow ",(0,i.jsx)(t.a,{href:"https://substrate.readme.io/v1.0.0/docs/creating-a-custom-substrate-chain#section-step-3-create-a-new-runtime-module",children:"this tutorial"})," we can learn the basics of building a new runtime module. Here is a link to the entire proof of existence runtime that I wrote: ",(0,i.jsx)(t.a,{href:"https://github.com/shawntabrizi/substrate-proof-of-existence/blob/e4011fca36f19b0d015c82f9badeb5ef644ea165/proof-of-existence/runtime/src/proof_of_existence.rs",children:"proof-of-existence/runtime/src/proof_of_existence.rs"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"a-closer-look",children:"A Closer Look"}),"\n",(0,i.jsx)(t.p,{children:"Let's take a look at a few of the different parts:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"decl_storage! {\n\ttrait Store for Module<T: Trait> as POEStorage {\n\t\tProofs get(proofs): map Vec<u8> => (T::AccountId, T::Moment);\n\t}\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["You can see our storage structure is quite simple. Just a mapping between a ",(0,i.jsx)(t.code,{children:"Vec<u8>"})," (bytearray) to a tuple of ",(0,i.jsx)(t.code,{children:"AccountID"})," and ",(0,i.jsx)(t.code,{children:"Moment"})," (the substrate equivalent of time)."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'fn create_claim(origin, digest: Vec<u8>) -> Result {\n    ensure!(!<Proofs<T>>::exists(&digest), "This digest has already been claimed");\n\n    let sender = ensure_signed(origin)?;\n    let time = <timestamp::Module<T>>::now();\n\n    <balances::Module<T>>::decrease_free_balance(&sender, <T::Balance as As<u64>>::sa(POE_FEE))?;\n    <Proofs<T>>::insert(&digest, (sender.clone(), time.clone()));\n\n    Self::deposit_event(RawEvent::ClaimCreated(sender, time, digest));\n    Ok(())\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["When the user calls the ",(0,i.jsx)(t.code,{children:"create_claim()"})," function, they provide a signed message including the digest they want to claim. We check that the digest has not already been claimed and that the messaged is signed, where we can also derive the AccountID of the sender."]}),"\n",(0,i.jsxs)(t.p,{children:["In my version of the runtime, we charge the user a fee to create a claim. For that operation, we call ",(0,i.jsx)(t.code,{children:"decrease_free_balance()"})," which will also check whether or not the full amount can be deducted from the account. If the account does not have enough funds, it will throw an error, which stops the transaction."]}),"\n",(0,i.jsxs)(t.p,{children:["Note that only after we have done all these checks do we modify the storage and ",(0,i.jsx)(t.code,{children:"insert()"})," the claim. This is important because if you modify the storage, and the transaction fails at some later point, the storage will remain modified. Substrate warns about this in ",(0,i.jsx)(t.a,{href:"https://github.com/paritytech/substrate/blob/v1.0/srml/example/src/lib.rs",children:"their documentation"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"// Since this is a dispatched function there are two extremely important things to\n// remember:\n//\n// - MUST NOT PANIC: Under no circumstances (save, perhaps, storage getting into an\n// irreparably damaged state) must this function panic.\n// - NO SIDE-EFFECTS ON ERROR: This function must either complete totally (and return\n// `Ok(())` or it must have no side-effects on storage and return `Err('Some reason')`.\n"})}),"\n",(0,i.jsx)(t.p,{children:"The revoke function is basically the same, but going the other direction:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'fn revoke_claim(origin, digest: Vec<u8>) -> Result {\n    ensure!(<Proofs<T>>::exists(&digest), "This digest has not been claimed yet");\n\n    let sender = ensure_signed(origin)?;\n    let (owner, _time) = Self::proofs(&digest);\n\n    ensure!(sender == owner, "You must own this claim to revoke it");\n\n    <Proofs<T>>::remove(&digest);\n    <balances::Module<T>>::increase_free_balance_creating(&sender, <T::Balance as As<u64>>::sa(POE_FEE));\n\n    Self::deposit_event(RawEvent::ClaimRevoked(sender, digest));\n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"We importantly check that the owner of the file is the same as the sender requesting to revoke the claim. After we remove the mapping from storage, we then return the funds which were initially spent to create the claim."}),"\n",(0,i.jsxs)(t.p,{children:["Both the ",(0,i.jsx)(t.code,{children:"create_claim()"})," and the ",(0,i.jsx)(t.code,{children:"revoke_claim()"})," function ends with an event being generated, which reports to the outside world when a user makes or revokes a claim. This event can be used to detect a successful transaction, or lack thereof."]}),"\n",(0,i.jsxs)(t.p,{children:["In addition to the ",(0,i.jsx)(t.code,{children:"proof_of_existence.rs"})," file we created, we also needed to modify other parts of the ",(0,i.jsx)(t.code,{children:"substrate-node-template"})," to integrate this new module into our blockchain. You can learn more about those details by ",(0,i.jsx)(t.a,{href:"https://substrate.readme.io/v1.0.0/docs/creating-a-custom-substrate-chain#section-step-4-integrate-our-new-module-into-our-runtime",children:"completing the tutorial"})," that we previously referenced."]}),"\n",(0,i.jsx)(t.h2,{id:"creating-a-user-interface-for-our-chain",children:"Creating a User Interface for Our Chain"}),"\n",(0,i.jsxs)(t.p,{children:["Now that we have completed our custom runtime, we need a way to allow our users to easily interact with this new functionality. For that, we will modify the ",(0,i.jsx)(t.a,{href:"https://github.com/paritytech/substrate-ui/tree/substrate-node-template",children:"substrate-ui"})," that we generated earlier."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.a,{href:"https://substrate.readme.io/v1.0.0/docs/creating-a-custom-substrate-chain#section-step-7-updating-our-substrate-ui",children:"custom runtime tutorial"})," already showed you some of the basics of modifying the ",(0,i.jsx)(t.code,{children:"substrate-ui"}),", but for our needs, we will need to write some custom React components."]}),"\n",(0,i.jsxs)(t.p,{children:["Here is what our segment in the ",(0,i.jsx)(t.code,{children:"app.jsx"})," file will look like:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-jsx",children:"{% raw %}\n<Segment style={{ margin: '1em' }} padded>\n\t<Header as='h2'>\n\t\t<Icon name='lock' />\n\t\t<Header.Content>\n\t\t\tProof of Existence\n\t\t\t<Header.Subheader>Claim ownership of your digital files</Header.Subheader>\n\t\t</Header.Content>\n\t</Header>\n\t<div style={{ paddingBottom: '1em' }}>\n\t\t<div style={{ fontSize: 'small' }}>Owner</div>\n\t\t<SignerBond bond={this.poeAccount} />\n\t\t<If condition={this.poeAccount.ready()} then={<span>\n\t\t\t<Label>Balance\n\t\t\t\t<Label.Detail>\n\t\t\t\t\t<Pretty value={runtime.balances.balance(this.poeAccount)} />\n\t\t\t\t</Label.Detail>\n\t\t\t</Label>\n\t\t</span>} />\n\t</div>\n\t<div>\n\t\t<FileDigestBond bond={this.poeDigest} content='Select File' />\n\t\t<DigestTag value={runtime.proof_of_existence.proofs(this.poeDigest)} account={this.poeAccount} />\n\t</div>\n\t<TransactButton\n\t\tcontent=\"Claim File\"\n\t\ticon='lock'\n\t\ttx={{\n\t\t\tsender: this.poeAccount,\n\t\t\tcall: calls.proof_of_existence.createClaim(this.poeDigest)\n\t\t}}\n\t/>\n</Segment>\n{% endraw %}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"custom-components",children:"Custom Components"}),"\n",(0,i.jsxs)(t.p,{children:["You can see we added two new components: the ",(0,i.jsx)(t.code,{children:"FileDigestBond"})," and the ",(0,i.jsx)(t.code,{children:"DigestTag"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"FileDigestBond"})," is very similar to the ",(0,i.jsx)(t.code,{children:"FileUploadBond"})," which is provided as a part of the ",(0,i.jsx)(t.code,{children:"substrate-ui"}),", but instead of returning the content of the file, it will return the digest by simply hashing that content. We can clone the ",(0,i.jsx)(t.code,{children:"FileUploadBond"})," component, and modify a small section like so:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:'if (file) {\n  this.state.name = file.name;\n  var fileReader = new FileReader();\n  fileReader.onloadend = (e) => {\n    let fileContents = new Uint8Array(e.target.result);\n    let fileDigest = "0x" + XXH.h64(fileContents.buffer, 0).toString(16);\n    this.props.bond.trigger(fileDigest);\n    this.setState({ digest: fileDigest });\n  };\n  fileReader.readAsArrayBuffer(file);\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Then to convey the current ownership status of a file, we create a fully custom ",(0,i.jsx)(t.code,{children:"DigestTag"})," component which will show who owns a file (if anyone) and when they claimed it. Here is what that looks like:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:'import React from "react";\nimport { ReactiveComponent } from "oo7-react";\nimport { Label } from "semantic-ui-react";\nimport { ss58Encode } from "oo7-substrate";\n\nexport class DigestTag extends ReactiveComponent {\n  constructor() {\n    super(["value", "account"]);\n  }\n\n  readyRender() {\n    if (this.state.value) {\n      let time = this.state.value[1];\n\n      // Check if time is 0, which implies not claimed\n      if (time.number == 0) {\n        return (\n          <Label basic color="green" pointing="left">\n            <span>Unclaimed!</span>\n          </Label>\n        );\n      } else {\n        let owner = ss58Encode(this.state.value[0]);\n\n        if (ss58Encode(this.state.account) == owner) {\n          return (\n            <Label basic color="green" pointing="left">\n              <span>\n                Owner: You!&emsp;|&emsp;When: {time.toLocaleDateString()}\n              </span>\n            </Label>\n          );\n        } else {\n          return (\n            <Label basic color="red" pointing="left">\n              <span>\n                Owner: {owner.substring(0, 8) + "\u2026"}&emsp;|&emsp;When:{" "}\n                {time.toLocaleDateString()}\n              </span>\n            </Label>\n          );\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"If we put everything together, and run it, we will get something like this:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"GIF of using the Proof of Existence UI",src:n(75659).Z+"",width:"600",height:"400"})}),"\n",(0,i.jsx)(t.h2,{id:"final-thoughts-and-next-steps",children:"Final Thoughts and Next Steps"}),"\n",(0,i.jsxs)(t.p,{children:["You can see that with relatively little effort, the Substrate framework allows you to build custom blockchains. Substrate itself provides you with all the infrastructure required to set up a node. The Substrate Runtime Module Library (SRML) gives you a package of pre-built tools and features that you can easily add to your blockchain. The ",(0,i.jsx)(t.code,{children:"substrate-node-template"})," can help you immediately get started with development, and the ",(0,i.jsx)(t.code,{children:"substrate-ui"})," can enable you or other users to quickly interact with your chain."]}),"\n",(0,i.jsx)(t.p,{children:"Obviously I have picked a very simple project to implement here, but this process has itself been very eye opening to the power of the platform, and has allowed me to become more familiar with these cutting edge tools. But we are not done here. As someone tinkering around, I feel pretty satisfied with my local setup, but this is a platform built to for production ready, scalable blockchains."}),"\n",(0,i.jsx)(t.p,{children:"The next steps for me will be to investigate:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"UI for revoking a claim"}),"\n",(0,i.jsx)(t.li,{children:"Token distribution patterns (maybe a timed faucet?)"}),"\n",(0,i.jsx)(t.li,{children:"Setting up bootnodes on a cloud provider"}),"\n",(0,i.jsx)(t.li,{children:"Creating/distributing binaries for others to run a node"}),"\n",(0,i.jsx)(t.li,{children:"???"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["As I tackle these different problems, I will make additional posts to keep you updated with what I learn along the way. You can always follow this project right on my GitHub: ",(0,i.jsx)(t.a,{href:"https://github.com/shawntabrizi/substrate-proof-of-existence",children:"https://github.com/shawntabrizi/substrate-proof-of-existence"}),". If you enjoy this content, or are looking forward to reading more about Substrate and blockchain development, feel free to check out my ",(0,i.jsx)(t.a,{href:"https://shawntabrizi.com/donate/",children:"donations page"}),". Thanks!"]})]})}function d(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},89409:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/Screen-Shot-2018-12-31-at-10.36.32-AM-6ec2f3efc32e895ae295d59c22ff1ba6.png"},75659:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/poe-example-3b2b31a4563e95431c752ecbc789a98d.gif"},11151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>a});var i=n(67294);const s={},o=i.createContext(s);function a(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);