"use strict";(self.webpackChunkshawntabrizi=self.webpackChunkshawntabrizi||[]).push([[8604],{91831:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>c});var a=n(85893),r=n(11151);const s={title:"Making Web3.js work asynchronously with JavaScript Promises and await",date:new Date("2017-11-24T08:47:40.000Z"),authors:"shawntabrizi",slug:"/ethereum/making-web3-js-work-asynchronously-javascript-promises-await/",categories:["Ethereum"],tags:["async","javascript","promises","web3"]},o=void 0,i={permalink:"/blog/ethereum/making-web3-js-work-asynchronously-javascript-promises-await/",source:"@site/blog/2017-11-24-making-web3-js-work-asynchronously-javascript-promises-await.md",title:"Making Web3.js work asynchronously with JavaScript Promises and await",description:'One of the things I learned when writing my "Hello World" tutorial for Ethereum and Web3.js was the importance of having your functions which call the blockchain run asynchronously. Without this, we would be unable to support users who use MetaMask as their Ethereum provider, and probably even more important, we may bring bad user experiences by locking up the browser during long HTTP requests. From the MetaMask developer FAQ:',date:"2017-11-24T08:47:40.000Z",tags:[{inline:!0,label:"async",permalink:"/blog/tags/async"},{inline:!0,label:"javascript",permalink:"/blog/tags/javascript"},{inline:!0,label:"promises",permalink:"/blog/tags/promises"},{inline:!0,label:"web3",permalink:"/blog/tags/web-3"}],readingTime:3.07,hasTruncateMarker:!1,authors:[{name:"Shawn Tabrizi",title:"Software Engineer",url:"https://github.com/shawntabrizi",imageURL:"https://github.com/shawntabrizi.png",key:"shawntabrizi",page:null}],frontMatter:{title:"Making Web3.js work asynchronously with JavaScript Promises and await",date:"2017-11-24T08:47:40.000Z",authors:"shawntabrizi",slug:"/ethereum/making-web3-js-work-asynchronously-javascript-promises-await/",categories:["Ethereum"],tags:["async","javascript","promises","web3"]},unlisted:!1,prevItem:{title:"ethfolio: A client side app to show your Ethereum token distribution",permalink:"/blog/ethereum/ethfolio-client-side-app-show-ethereum-token-distribution/"},nextItem:{title:"Ethereum Token Contract ABI in Web3.js for ERC-20 and Human Standard Tokens",permalink:"/blog/ethereum/ethereum-token-contract-abi-web3-erc-20-human-standard-tokens/"}},l={authorsImageUrls:[void 0]},c=[{value:"Turning Web3.js functions into JavaScript Promises",id:"turning-web3js-functions-into-javascript-promises",level:2}];function h(e){const t={a:"a",blockquote:"blockquote",code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["One of the things I learned when writing my ",(0,a.jsx)(t.a,{href:"https://shawntabrizi.com/ethereum/correcting-ethereum-web3-js-hello-world/",children:'"Hello World" tutorial for Ethereum and Web3.js'})," was the importance of having your functions which call the blockchain run asynchronously. Without this, we would be unable to support users who use MetaMask as their Ethereum provider, and probably even more important, we may bring bad user experiences by locking up the browser during long HTTP requests. From the MetaMask developer FAQ:"]}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"Using synchronous calls is both a technical limitation and a user experience issue. They block the user's interface. So using them is a bad practice, anyway. Think of this API restriction as a gift to your users."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Setting up a Web3 function to work asynchronously was pretty easy to figure out for a single call; but what about making multiple calls through Web3, that all need to be asynchronous, but also have dependencies on one another?"}),"\n",(0,a.jsx)(t.p,{children:"An example would be calculating the ERC-20 token balance of an Ethereum address. To do this, you need to know both the balance of tokens at the address, but also the decimals value for that token to convert to the right units. JavaScript Promises are the natural solution here. They allow you to track the status of an asynchronous function, and perform actions after your multiple dependencies all resolve."}),"\n",(0,a.jsx)(t.h2,{id:"turning-web3js-functions-into-javascript-promises",children:"Turning Web3.js functions into JavaScript Promises"}),"\n",(0,a.jsxs)(t.p,{children:["In my ",(0,a.jsx)(t.a,{href:"https://shawntabrizi.com/ethereum/correcting-ethereum-web3-js-hello-world/",children:'"Hello World" tutorial'}),", I show you can make an asynchronous requests by adding an error first callback to the Web3.js functions:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"web3.eth.getBalance(address, function (error, result) {\n  if (!error) {\n    console.log(result);\n  } else {\n    console.error(error);\n  }\n});\n"})}),"\n",(0,a.jsxs)(t.p,{children:["As I mentioned, if we depend on multiple calls from the Ethereum blockchain to create a result, using ",(0,a.jsx)(t.a,{href:"https://developers.google.com/web/fundamentals/primers/promises",children:"JavaScript Promises"})," is a good solution. They allow you to react to a success or a failure from an asynchronous function. Creating a promise from the error first callback function is pretty straightforward:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"function getBalance (address) {\n  return new Promise (function (resolve, reject) {\n    web3.eth.getBalance(address, function (error, result) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(result);\n    }\n  })\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"But we can actually make this process even simpler for multiple Web3 functions by creating a wrapper which both makes the function asynchronous, and turn it into a promise; basically automating what we would repeat above for each different Web3 function we call."}),"\n",(0,a.jsxs)(t.p,{children:["Here is the wrapper from ",(0,a.jsx)(t.a,{href:"https://ethereum.stackexchange.com/a/24238/19577",children:"0xcaff posted in StackExchange"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"const promisify = (inner) =>\n  new Promise((resolve, reject) =>\n    inner((err, res) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(res);\n      }\n    })\n  );\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Now that we have a Promise, we can take advantage of the ",(0,a.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function",children:"async/await pattern"})," which simplifies not only the look, but also the behavior of Promises."]}),"\n",(0,a.jsxs)(t.p,{children:['Putting this all together, let\'s show how simple this makes getting the token balance for an ETH account. We convert our original "Hello World" ',(0,a.jsx)(t.code,{children:"getBalance"})," into an asynchronous function, like so:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:'async function getBalance() {\n  var address, wei, balance;\n  address = document.getElementById("address").value;\n  wei = promisify((cb) => web3.eth.getBalance(address, cb));\n  try {\n    balance = web3.fromWei(await wei, "ether");\n    document.getElementById("output").innerHTML = balance + " ETH";\n  } catch (error) {\n    document.getElementById("output").innerHTML = error;\n  }\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["Not much shorter for a single function, but will certainly make things better the more separate functions we call. My next post will show the results of these smaller educational posts, and how we can put it together to create the project I have been hinting above: ",(0,a.jsx)(t.a,{href:"https://github.com/shawntabrizi/ERC20-Token-Balance",children:"Getting the ERC-20 balance of an Ethereum Address"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["I hope this teaches you something! Again, this may be trivial to many, but was not so straightforward when I first started to tackling these problems. If it did help you, feel free to support me with a ",(0,a.jsx)(t.a,{href:"https://shawntabrizi.com/donate/",children:"small donation."})]})]})}function u(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>o});var a=n(67294);const r={},s=a.createContext(r);function o(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);