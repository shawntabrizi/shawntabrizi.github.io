"use strict";(self.webpackChunkshawntabrizi=self.webpackChunkshawntabrizi||[]).push([[8535],{42947:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var o=n(85893),a=n(11151);const i={title:"Extending Substrate Runtime Modules",date:new Date("2019-06-28T00:14:03.000Z"),authors:"shawntabrizi",layout:"post",slug:"/substrate/extending-substrate-runtime-modules/",categories:["Substrate"],tags:["runtime","module","rust","sudo","contracts","ink"],github:"sudo-contract"},s=void 0,r={permalink:"/blog/substrate/extending-substrate-runtime-modules/",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2019-06-27-extending-substrate-runtime-modules.md",source:"@site/blog/2019-06-27-extending-substrate-runtime-modules.md",title:"Extending Substrate Runtime Modules",description:"In this post, I will show you how you can extend the SRML Contracts module to add additional authorization layers to your smart contract blockchain.",date:"2019-06-28T00:14:03.000Z",formattedDate:"June 28, 2019",tags:[{label:"runtime",permalink:"/blog/tags/runtime"},{label:"module",permalink:"/blog/tags/module"},{label:"rust",permalink:"/blog/tags/rust"},{label:"sudo",permalink:"/blog/tags/sudo"},{label:"contracts",permalink:"/blog/tags/contracts"},{label:"ink",permalink:"/blog/tags/ink"}],readingTime:15.505,hasTruncateMarker:!1,authors:[{name:"Shawn Tabrizi",title:"Software Engineer",url:"https://github.com/shawntabrizi",imageURL:"https://github.com/shawntabrizi.png",key:"shawntabrizi"}],frontMatter:{title:"Extending Substrate Runtime Modules",date:"2019-06-28T00:14:03.000Z",authors:"shawntabrizi",layout:"post",slug:"/substrate/extending-substrate-runtime-modules/",categories:["Substrate"],tags:["runtime","module","rust","sudo","contracts","ink"],github:"sudo-contract"},unlisted:!1,prevItem:{title:"Querying Substrate Storage via RPC",permalink:"/blog/substrate/querying-substrate-storage-via-rpc/"},nextItem:{title:"Adding Fees to Your Substrate Runtime Module",permalink:"/blog/substrate/adding-fees-to-your-substrate-runtime-module/"}},c={authorsImageUrls:[void 0]},d=[{value:"In this post, I will show you how you can extend the SRML Contracts module to add additional authorization layers to your smart contract blockchain.",id:"in-this-post-i-will-show-you-how-you-can-extend-the-srml-contracts-module-to-add-additional-authorization-layers-to-your-smart-contract-blockchain",level:5},{value:"Background",id:"background",level:2},{value:"Permissioned Access",id:"permissioned-access",level:2},{value:"Creating Sudo Contract",id:"creating-sudo-contract",level:2},{value:"Wrapping a Module",id:"wrapping-a-module",level:3},{value:"Adding Authorization Checks",id:"adding-authorization-checks",level:3},{value:"Other Details",id:"other-details",level:3},{value:"Accessing Other Modules",id:"accessing-other-modules",level:4},{value:"Calling Private Dispatchable Functions",id:"calling-private-dispatchable-functions",level:4},{value:"Adding Sudo Contract",id:"adding-sudo-contract",level:2},{value:"Substrate Dependencies",id:"substrate-dependencies",level:3},{value:"Tricking the Polkadot UI",id:"tricking-the-polkadot-ui",level:3},{value:"Making SRML Contract &quot;Un-Callable&quot;",id:"making-srml-contract-un-callable",level:3},{value:"Testing Sudo Contract",id:"testing-sudo-contract",level:2},{value:"Putting Code On the Chain",id:"putting-code-on-the-chain",level:3},{value:"Next Steps",id:"next-steps",level:2}];function l(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",h5:"h5",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h5,{id:"in-this-post-i-will-show-you-how-you-can-extend-the-srml-contracts-module-to-add-additional-authorization-layers-to-your-smart-contract-blockchain",children:"In this post, I will show you how you can extend the SRML Contracts module to add additional authorization layers to your smart contract blockchain."}),"\n",(0,o.jsx)(t.p,{children:'One of the best things about Substrate is the ability to easily execute on your ideas when developing blockchain systems. I want to show you a question from the first Substrate Developer Conference (Sub0) that lead to me investigating how one might extend the functionality of a runtime module with a "wrapper module".'}),"\n",(0,o.jsx)(t.p,{children:"Before we can jump in though, you will need to know a little about how the Substrate Contract module works."}),"\n",(0,o.jsx)(t.h2,{id:"background",children:"Background"}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.a,{href:"https://substrate.dev/rustdocs/v1.0/srml_contract/index.html",children:"Contract module"})," is included in the Substrate Runtime Module Library (SRML) and provides your blockchain with the ability to execute Wasm smart contracts."]}),"\n",(0,o.jsx)(t.p,{children:"There is a two step process for deploying a smart contract using the Contract module:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Putting the WebAssembly smart contract code on the blockchain."}),"\n",(0,o.jsx)(t.li,{children:"Creating an instance of a smart contract with a new Contract account."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"This has a major advantage over existing smart contract platforms since you are able to create multiple instances of the same smart contract without needing to waste additional space with multiple instances of the contract code. For example, on Ethereum, each and every ERC-20 token uploads their own version of the ERC-20 contract. In Substrate, and with the Contracts module, a single ERC-20 Wasm smart contract can be uploaded, and many people can deploy their own tokens using customizable deployment parameters like initial balance, token name, etc..."}),"\n",(0,o.jsx)(t.h2,{id:"permissioned-access",children:"Permissioned Access"}),"\n",(0,o.jsx)(t.p,{children:"So now that you are familiar with how to deploy contracts using the Contract module, let's hear the question that was asked at Sub0:"}),"\n",(0,o.jsx)("iframe",{width:"720px",height:"480px",src:"https://www.youtube.com/embed/-EJHu0u6hT8?start=6405&end=6573",frameborder:"0",allow:"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:'Question: "Can you restrict which accounts can add code to the blockchain?"'}),"\n"]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:'Sergei: "Maybe you can write another module which just wraps the smart contract module, and just does this additional check..."'}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["While there are a few different ways you could approach solving this problem, it turns out ",(0,o.jsx)(t.a,{href:"https://github.com/pepyakin",children:"Sergei"}),", as always, was absolutely correct about the best approach."]}),"\n",(0,o.jsxs)(t.p,{children:["One ",(0,o.jsx)(t.em,{children:"could"})," copy the entire Contract module and make changes directly to the source code (as I had originally suggested), but that means that any future updates and improvement to the Contract module would need to get added back into your fork of the module manually. This is definitely not a recommended approach, and one that I believe most users will naturally avoid anyway."]}),"\n",(0,o.jsx)(t.p,{children:'Rather, creating a "wrapper module" which somehow applies itself on top of the existing SRML Contract module, but allows for additional logic to be added, would be the best here. It would create clear separation between the vanilla module and the changes made by the end user, and would allow for the module to automatically stay up to date with the latest changes to Substrate.'}),"\n",(0,o.jsx)(t.p,{children:"So how would we do this?"}),"\n",(0,o.jsx)(t.h2,{id:"creating-sudo-contract",children:"Creating Sudo Contract"}),"\n",(0,o.jsxs)(t.p,{children:["I have created a Substrate runtime module called ",(0,o.jsx)(t.a,{href:"https://github.com/shawntabrizi/sudo-contract",children:(0,o.jsx)(t.code,{children:"sudo-contract"})})," which, as suggested, wraps the SRML Contract module, and provides a simple example on how you might execute similar wrapper modules."]}),"\n",(0,o.jsxs)(t.p,{children:["As the name implies, ",(0,o.jsx)(t.code,{children:"sudo-contract"}),' uses both the SRML Sudo module and the SRML Contract module to make it so that only the "Sudo key" can put contract code on the blockchain. We did not change any other logic though, so there are no limits on who can deploy or call an instance of this smart contract. This combination of authorization to ',(0,o.jsx)(t.code,{children:"put_code"}),", with open access to ",(0,o.jsx)(t.code,{children:"create"})," and ",(0,o.jsx)(t.code,{children:"call"})," enables for some practical use cases."]}),"\n",(0,o.jsxs)(t.p,{children:["For example, imagine a DeFi (decentralized finance) platform controlled by a trusted smart contract development team like ",(0,o.jsx)(t.a,{href:"https://github.com/OpenZeppelin",children:"OpenZeppelin"}),". This team would be able to provide a number of standardized, audited, and safe contracts for their users like an ICO contract, ERC-20 Contract, Multi-Signature Contract, etc... Users of this platform can choose from any of the standard contracts provided by the authorized team, and make their own instance of it for their needs."]}),"\n",(0,o.jsxs)(t.p,{children:["With ",(0,o.jsx)(t.code,{children:"sudo-contract"}),", this team would be able to tell their users that all smart contracts on their blockchain have been created and audited by their team. Thus, users can feel safe that there is no malicious code, backdoors, or generally broken contracts when using this platform."]}),"\n",(0,o.jsx)(t.p,{children:"This could provide a safer, and more consistent experience to all parties trying to take part in a larger decentralized financial system. Hopefully, you can imagine that the same can be done for other classes of smart contracts too!"}),"\n",(0,o.jsx)(t.p,{children:"So now that you are convinced of the utility of such a module, let's show you how you can build it."}),"\n",(0,o.jsx)(t.h3,{id:"wrapping-a-module",children:"Wrapping a Module"}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"sudo-contract"})," module needs to provide all the same functionalities of the SRML Contract module, but have additional authorization checks around just one of the functions: ",(0,o.jsx)(t.code,{children:"put_code"}),"."]}),"\n",(0,o.jsx)(t.p,{children:'As Sergei suggested, the best way to approach this is to write a "wrapper module", which basically means a module which exposes the same extrinsic calls as the Contract module and forwards those calls to the real Contract module.'}),"\n",(0,o.jsx)(t.p,{children:"For example, the Contract module exposes 4 dispatchable functions:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"update_schedule"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"put_code"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"create"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"call"})}),"\n"]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Note:"})," We do not include special functions like ",(0,o.jsx)(t.code,{children:"on_initialize"}),", ",(0,o.jsx)(t.code,{children:"on_finalize"}),", ",(0,o.jsx)(t.code,{children:"deposit_event"}),", etc... Only the ones which can be called via an extrinsic."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["In our ",(0,o.jsx)(t.code,{children:"sudo-contract"}),' module, one of these "wrapper functions" will look like this:']}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-rust",children:"/// Simply forwards to the `create` function in the Contract module.\nfn create(\n    origin,\n    #[compact] endowment: BalanceOf<T>,\n    #[compact] gas_limit: T::Gas,\n    code_hash: CodeHash<T>,\n    data: Vec<u8>\n) -> Result {\n    <contract::Module<T>>::create(origin, endowment, gas_limit, code_hash, data)\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["All I have done here is copy the function signature for the ",(0,o.jsx)(t.code,{children:"create"})," function, and then passed those parameters to the real ",(0,o.jsx)(t.code,{children:"<contract::Module<T>>::create"}),' function. You would do the same thing with each function until you have essentially created a "wrapped" module!']}),"\n",(0,o.jsx)(t.h3,{id:"adding-authorization-checks",children:"Adding Authorization Checks"}),"\n",(0,o.jsx)(t.p,{children:"Creating a wrapper module like we have done above is not very useful as is, but using this pattern, we now have the ability to execute some additional logic before or after the main SRML Contract functions!"}),"\n",(0,o.jsxs)(t.p,{children:["Our goal here is to add some additional authorization logic before the ",(0,o.jsx)(t.code,{children:"put_code"})," function, where only the Sudo key can call this function. That is actually really easy and can be done like so:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-rust",children:'/// Checks that sender is the Sudo `key` before forwarding to `put_code` in the Contract module.\nfn put_code(\n    origin,\n    #[compact] gas_limit: T::Gas,\n    code: Vec<u8>\n) -> Result {\n    let sender = ensure_signed(origin)?;\n    ensure!(sender == <sudo::Module<T>>::key(), "Sender must be the Sudo key to put_code");\n    let new_origin = system::RawOrigin::Signed(sender).into();\n    <contract::Module<T>>::put_code(new_origin, gas_limit, code)\n}\n'})}),"\n",(0,o.jsx)(t.p,{children:"Here, we simply call into the Sudo module's storage to retrieve who the current Sudo key is, and check that the sender matches that key. If that check fails, we never make the downstream call to the SRML Contract module to actually put the code on the chain. Instead the module will return a runtime error:"}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"Sender must be the Sudo key to put_code"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"and nothing will happen. It really is that easy!"}),"\n",(0,o.jsx)(t.h3,{id:"other-details",children:"Other Details"}),"\n",(0,o.jsx)(t.p,{children:"I won't go into a line by line instruction of creating the module, but there a few details I want to call out so that even new runtime developers can understand how some things work."}),"\n",(0,o.jsx)(t.h4,{id:"accessing-other-modules",children:"Accessing Other Modules"}),"\n",(0,o.jsxs)(t.p,{children:["In my wrapper module, I have dependencies on both the SRML Contract module and SRML Sudo module. You can see in my code, I reference both modules to either call their functions or to read their storage. I am able to do this because I have imported these dependencies in my module's ",(0,o.jsx)(t.code,{children:"Cargo.toml"})," file, and I have inherited the modules' traits into my own:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-rust",children:"pub trait Trait: contract::Trait + sudo::Trait {}\n"})}),"\n",(0,o.jsx)(t.p,{children:"You will need to do this for any modules you wrap, and in our case this also implies that your runtime must use exactly these two modules."}),"\n",(0,o.jsx)(t.p,{children:"We may look to revisit a wrapper module which does not depend on any specific module, but just one that has the traits, functions, and types expected. You could imagine this would be useful if another Contract module was released with alternative implementation details, but ultimately the same API. We would want our wrapper module to work for that module too!"}),"\n",(0,o.jsx)(t.h4,{id:"calling-private-dispatchable-functions",children:"Calling Private Dispatchable Functions"}),"\n",(0,o.jsxs)(t.p,{children:['A critical detail which makes this solution work so "easily" is that the dispatchable functions for the Contract module are marked ',(0,o.jsx)(t.code,{children:"pub"}),", which means I can call them directly from my wrapper module. However, this is not a requirement for making a wrapper module since all dispatchable functions are made explicitly public through the ",(0,o.jsx)(t.code,{children:"Call"}),' type. What this really means is that your module can always "dispatch" a transaction to another module\'s function!']}),"\n",(0,o.jsx)(t.p,{children:"Here is an example of what that might look like:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-rust",children:"let result = contract::Call::<T>::update_schedule(schedule).dispatch(origin).is_ok();\n"})}),"\n",(0,o.jsx)(t.p,{children:"This is exactly the same as calling the function directly, so no extra transactions will be recorded, no extra fees taken, etc..."}),"\n",(0,o.jsx)(t.h2,{id:"adding-sudo-contract",children:"Adding Sudo Contract"}),"\n",(0,o.jsxs)(t.p,{children:["So I have already done the work for you to create the ",(0,o.jsx)(t.code,{children:"sudo-contract"})," wrapper module. Now I want to share with you some of the nuances of adding it to your smart contract enabled runtime."]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Note:"})," If you want to add the ",(0,o.jsx)(t.code,{children:"sudo-contract"})," module to your runtime, you should follow the ",(0,o.jsx)(t.a,{href:"https://github.com/shawntabrizi/sudo-contract",children:"README"})," included with the module, since the next couple of sections may leave out smaller details."]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"substrate-dependencies",children:"Substrate Dependencies"}),"\n",(0,o.jsx)(t.p,{children:"I won't go into details about the challenges in creating a Substrate module as its own Rust library, but one thing you will need to be conscious of is the specific Substrate dependencies used by your runtime code."}),"\n",(0,o.jsxs)(t.p,{children:["In the ",(0,o.jsx)(t.code,{children:"v1.0"})," branch of the ",(0,o.jsx)(t.code,{children:"sudo-contract"})," module, I point all Substrate dependencies to the ",(0,o.jsx)(t.code,{children:"v1.0"})," branch of Substrate. This means your runtime must ",(0,o.jsx)(t.strong,{children:"also"})," have all of its substrate dependencies point to the ",(0,o.jsx)(t.code,{children:"v1.0"})," branch too. If your runtime is pointing to a specific git commit or a different branch, you will either need to update your runtime code or fork my wrapper module and update it to use exactly the same dependency."]}),"\n",(0,o.jsxs)(t.p,{children:["You will also need to be sure to add this module to your runtime's ",(0,o.jsx)(t.code,{children:"std"})," feature, so that it will use ",(0,o.jsx)(t.code,{children:"std"})," features when building the native binaries for your runtime."]}),"\n",(0,o.jsxs)(t.p,{children:["More details can be found in README for the ",(0,o.jsx)(t.code,{children:"sudo-contract"})," module and the HOWTO of the ",(0,o.jsx)(t.a,{href:"https://github.com/shawntabrizi/substrate-module-template",children:(0,o.jsx)(t.code,{children:"substrate-module-template"})}),", which was used to create the ",(0,o.jsx)(t.code,{children:"sudo-contract"})," module."]}),"\n",(0,o.jsx)(t.h3,{id:"tricking-the-polkadot-ui",children:"Tricking the Polkadot UI"}),"\n",(0,o.jsxs)(t.p,{children:["The next challenge we will overcome is how to trick the Polkadot UI into thinking our ",(0,o.jsx)(t.code,{children:"sudo-contract"}),' module, with the same public API, is the "real" Contract module of my chain.']}),"\n",(0,o.jsxs)(t.p,{children:["The Polkadot UI is actually really simple when it comes to enabling and routing logic to module specific UI like the Contract module. All it does is check in the runtime metadata that the ",(0,o.jsx)(t.code,{children:"name"})," of the module matches what it expects."]}),"\n",(0,o.jsx)(t.p,{children:"This metadata value is generated from the Rust dependency name chosen when importing the module into your project. So in the case of the SRML Contract module, you would normally import the module like this:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"[dependencies.contract]\ndefault_features = false\ngit = 'https://github.com/paritytech/substrate.git'\npackage = 'srml-contract'\nbranch = 'v1.0'\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Which would give it ",(0,o.jsx)(t.code,{children:'"name": "contract"'})," in the metadata, which is exactly what the UI expects. So, we would be able to trick the UI by taking advantage of this and importing our module with the ",(0,o.jsx)(t.code,{children:"contract"})," dependency name, and renaming the SRML Contract module:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"[dependencies.srml-contract]\ndefault_features = false\ngit = 'https://github.com/paritytech/substrate.git'\npackage = 'srml-contract'\nbranch = 'v1.0'\n\n[dependencies.contract]\ndefault_features = false\ngit = 'https://github.com/shawntabrizi/sudo-contract.git'\npackage = 'sudo-contract'\nbranch = 'v1.0'\n"})}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Note"})," that we imported our ",(0,o.jsx)(t.code,{children:"sudo-contract"})," package from the ",(0,o.jsx)(t.code,{children:"v1.0"})," branch, and our Substrate based depdencies are also coming from their ",(0,o.jsx)(t.code,{children:"v1.0"})," branch, as described in the previous section."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["After making this change and updating our ",(0,o.jsx)(t.code,{children:"std"})," feature appropriately, we will also need to update our runtime's ",(0,o.jsx)(t.code,{children:"lib.rs"})," file."]}),"\n",(0,o.jsxs)(t.p,{children:["Any references to the ",(0,o.jsx)(t.code,{children:"contract"})," dependency which is intended for ",(0,o.jsx)(t.code,{children:"srml-contract"})," will need to be updated, like the trait implementations:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-rust",children:"// This is the srml-contract Trait\nimpl srml_contract::Trait for Runtime {\n\ttype Currency = Balances;\n\ttype Call = Call;\n\ttype Event = Event;\n\ttype Gas = u64;\n    // Note the updated names in these lines too!\n\ttype DetermineContractAddress = srml_contract::SimpleAddressDeterminator<Runtime>;\n\ttype ComputeDispatchFee = srml_contract::DefaultDispatchFeeComputor<Runtime>;\n\ttype TrieIdGenerator = srml_contract::TrieIdFromParentCounter<Runtime>;\n\ttype GasPayment = ();\n}\n\n// This is the sudo-contract Trait\nimpl contract::Trait for Runtime {}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["With these changes, the Polkadot UI should think that the ",(0,o.jsx)(t.code,{children:"sudo-contract"})," module is indeed the regular Contract module, and provide you with a great user experience for interacting with Smart Contracts, without any additional work from your side."]}),"\n",(0,o.jsx)(t.h3,{id:"making-srml-contract-un-callable",children:'Making SRML Contract "Un-Callable"'}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"sudo-contract"})," module would be pretty useless if it was possible to still call the contract module directly, bypassing this authorization check we just added. However, the whole point of this project is to keep the original module around so we aren't forking things."]}),"\n",(0,o.jsxs)(t.p,{children:["Fortunately, it seems that Substrate was designed to be so modular and customizable that this scenario is already supported! ",(0,o.jsx)(t.a,{href:"https://github.com/paritytech/substrate/pull/2399#issuecomment-487597233",children:"From Gav"}),":"]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:["You can introduce a module entry into the runtime without the ",(0,o.jsx)(t.code,{children:"Call"})," functionality which will prevent it from being routed to in a transaction."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["What he is saying here is that whereas we would normally import our SRML Contract module into the ",(0,o.jsx)(t.code,{children:"construct_runtime!"})," macro like so:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-rust",children:"Contract: srml_contract::{Module, Call, Storage, Config<T>, Event<T>},\n"})}),"\n",(0,o.jsxs)(t.p,{children:["We can simply omit the ",(0,o.jsx)(t.code,{children:"Call"}),' type, and it will make our module "un-callable". This does not affect any of the other basic functionalities of our runtime like the module storage, module events, and even genesis configuration.']}),"\n",(0,o.jsxs)(t.p,{children:["Then, when adding our ",(0,o.jsx)(t.code,{children:"sudo-contract"})," module, we ",(0,o.jsx)(t.em,{children:"do"})," include the ",(0,o.jsx)(t.code,{children:"Call"})," type, but nothing else since our wrapper module does not have any storage or events of its own (but it could so don't think this is a limitation). Here is what our final ",(0,o.jsx)(t.code,{children:"construct_runtime!"})," import would look like for these two modules:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"Contract: srml_contract::{Module, Storage, Config<T>, Event<T>},\nSudoContract: contract::{Module, Call},\n"})}),"\n",(0,o.jsx)(t.h2,{id:"testing-sudo-contract",children:"Testing Sudo Contract"}),"\n",(0,o.jsxs)(t.p,{children:["So now that we have successfully added the ",(0,o.jsx)(t.code,{children:"sudo-contract"})," module to our runtime, let's take a look at what happens when we use it."]}),"\n",(0,o.jsxs)(t.p,{children:["I have a ",(0,o.jsxs)(t.a,{href:"https://github.com/shawntabrizi/substrate-package/tree/sudo-contract",children:[(0,o.jsx)(t.code,{children:"sudo-contract"})," branch"]})," in the ",(0,o.jsx)(t.code,{children:"substrate-package"})," which you can use to run this wrapper module yourself, or double check the steps ",(0,o.jsx)(t.a,{href:"https://github.com/shawntabrizi/substrate-package/commit/c0c1e4604db279c5940f528c378575fa2c5aaf7a",children:"in this PR"})," for adding it to your own runtime."]}),"\n",(0,o.jsx)(t.p,{children:"We build the Wasm runtime and the native binaries to start our node:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-bash",children:"./scripts/build.sh\ncargo build --release\n./target/release/node-template purge-chain --dev\n./target/release/node-template --dev\n"})}),"\n",(0,o.jsx)(t.p,{children:"When we run the node, we can interact with it using the Polkadot UI. We can immediately see that the UI recognizes that we have the Contract module included in our runtime:"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Screenshot of the Polkadot UI with Contract Tab",src:n(67889).Z+"",width:"2244",height:"1400"})}),"\n",(0,o.jsxs)(t.p,{children:["If we dig a little deeper into the details, we can see that the extrinsics section uses our ",(0,o.jsx)(t.code,{children:"sudo-contract"})," version of the Contract module functions:"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Screenshot of the Contract Extrinsics",src:n(55602).Z+"",width:"2244",height:"1400"})}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:'Notice that the comments with each function are the ones that we wrote in the wrapper module, and there are no other "contract" modules which can be called.'}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Finally, if we look at the chain state tab, we will see that the UI and our runtime still manages the full storage of the SRML Contract module and that our module has no storage itself:"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Screenshot of the Contract Extrinsics",src:n(47377).Z+"",width:"2244",height:"1400"})}),"\n",(0,o.jsx)(t.p,{children:"So really we have set up our runtime exactly as we want."}),"\n",(0,o.jsx)(t.p,{children:"Let's now try to use the Contract UI to create a new contract on our blockchain!"}),"\n",(0,o.jsx)(t.h3,{id:"putting-code-on-the-chain",children:"Putting Code On the Chain"}),"\n",(0,o.jsxs)(t.p,{children:["If our ",(0,o.jsx)(t.code,{children:"sudo-contract"})," module is really working, then only the Sudo key will be able to put new contracts onto the blockchain. Since we are running a ",(0,o.jsx)(t.code,{children:"--dev"})," chain, Alice is set as the Sudo key at the genesis of our blockchain."]}),"\n",(0,o.jsxs)(t.p,{children:["So let's first try to put a new smart contract with ",(0,o.jsx)(t.em,{children:"another"}),' account. Let\'s fund Bob with enough units to deploy a contract, and try to upload the standard "flipper" contract. Here is what we will see in the UI:']}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"UI error message when Bob tries to upload contract",src:n(51411).Z+"",width:"2244",height:"1400"})}),"\n",(0,o.jsx)(t.p,{children:'When we look at our node terminal to see what "went wrong" we find:'}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Terminal error message when Bob tries to upload contract",src:n(18122).Z+"",width:"1392",height:"954"})}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:'"Runtime: Sender must be the Sudo key to put_code"'}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"So our wrapper module is indeed gating access to the underlying SRML Contract module."}),"\n",(0,o.jsx)(t.p,{children:"Now we will try with Alice:"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Success when Alice tries to upload contract",src:n(28395).Z+"",width:"2244",height:"1400"})}),"\n",(0,o.jsxs)(t.p,{children:["A success! Note that the ",(0,o.jsx)(t.code,{children:"CodeStored"})," event which is emitted comes from ",(0,o.jsx)(t.code,{children:"srmlContract"}),", which means ultimately the SRML Contract module is doing all of the work here. Our wrapper module is only doing the minimal it needs to in order to gate access. After this point, Bob or any other user can now create an instance of this contract."]}),"\n",(0,o.jsx)(t.p,{children:"We have successfully extended the SRML Contract module without making any forks or direct changes!"}),"\n",(0,o.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsx)(t.p,{children:"While this post touches on a number of nuanced details about how we use Substrate to enable this end to end scenario, the big picture idea here should still be quite simple. You have now learned one approach to extending other Substrate runtime modules, and the possibilities with this are endless."}),"\n",(0,o.jsx)(t.p,{children:"Here are some ideas you could try to hack on:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Wrapper for the SRML Contract module which keeps track of all contracts that are uploaded with some additional metadata."}),"\n",(0,o.jsxs)(t.li,{children:['Wrapper for the SRML Balances module which adds a "pause" functionality to the blockchain, preventing calls to ',(0,o.jsx)(t.code,{children:"transfer"}),"."]}),"\n",(0,o.jsx)(t.li,{children:'Wrapper to the SRML Contract module which adds the ability for the Sudo key to "update" the Wasm code of a contract. (This will hopefully be the topic of a future post).'}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["Also, this implementation of ",(0,o.jsx)(t.code,{children:"sudo-contract"})," is not perfect. If you wanted to improve it, consider adding any of the following:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:'Adding module storage and some basic functions which allow you to control "privileged" accounts and remove the dependency on SRML Sudo.'}),"\n",(0,o.jsx)(t.li,{children:"Abstract away direct dependency on the SRML Contract module, and have the module work for wrapping any module which exposes the same dispatchable functions."}),"\n",(0,o.jsxs)(t.li,{children:["Add a second tier of authorization for ",(0,o.jsx)(t.code,{children:"create"})," so that only some users can ",(0,o.jsx)(t.code,{children:"put_code"}),", a larger (but still limited) set of users can ",(0,o.jsx)(t.code,{children:"create"}),", but then all users can ",(0,o.jsx)(t.code,{children:"call"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["I hope that someone uses the ",(0,o.jsx)(t.code,{children:"sudo-contract"})," module in their production blockchain. If you do end up using it, please let me know!"]}),"\n",(0,o.jsxs)(t.p,{children:["As always, if you like the content I produce and want to help me keep doing it, take a look at my ",(0,o.jsx)(t.a,{href:"https://shawntabrizi.com/donate/",children:"donation page"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},55602:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/sudo-contract-call-7a29538531aa49bd1436e51a97a513a4.png"},47377:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/sudo-contract-chain-state-01099038e8220bdb726769dfe8aa058a.png"},67889:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/sudo-contract-polkadot-ui-8de34e2d05e79d073f5217f4efa7d194.png"},18122:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/sudo-contract-terminal-error-013dfdb2ac8b2f1864ef3f703b96e6c6.png"},51411:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/sudo-contract-ui-error-60222c4ade300ecddbb0aadddbca5bcc.png"},28395:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/sudo-contract-ui-success-4acdcfe0aa2ace9c15c14e5f91d1a198.png"},11151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>s});var o=n(67294);const a={},i=o.createContext(a);function s(e){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),o.createElement(i.Provider,{value:t},e.children)}}}]);