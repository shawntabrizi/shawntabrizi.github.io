"use strict";(self.webpackChunkshawntabrizi=self.webpackChunkshawntabrizi||[]).push([[48457],{5114:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>h,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>a});var n=i(85893),s=i(11151);const o={title:"The Sudo Story in Substrate",date:new Date("2019-03-14T17:05:44.000Z"),authors:"shawntabrizi",slug:"/substrate/the-sudo-story-in-substrate/",categories:["Substrate"]},r=void 0,l={permalink:"/blog/substrate/the-sudo-story-in-substrate/",source:"@site/blog/2019-03-14-the-sudo-story-in-substrate.md",title:"The Sudo Story in Substrate",description:"In this post, I will explain how the Sudo module is used to access permissioned functions in Substrate.",date:"2019-03-14T17:05:44.000Z",formattedDate:"March 14, 2019",tags:[],readingTime:6.535,hasTruncateMarker:!1,authors:[{name:"Shawn Tabrizi",title:"Software Engineer",url:"https://github.com/shawntabrizi",imageURL:"https://github.com/shawntabrizi.png",key:"shawntabrizi"}],frontMatter:{title:"The Sudo Story in Substrate",date:"2019-03-14T17:05:44.000Z",authors:"shawntabrizi",slug:"/substrate/the-sudo-story-in-substrate/",categories:["Substrate"]},unlisted:!1,prevItem:{title:"Substrate Smart Contracts Workshop",permalink:"/blog/substrate/substrate-smart-contracts-workshop/"},nextItem:{title:"Substrate at FOSDEM 2019",permalink:"/blog/substrate/substrate-at-fosdem-2019/"}},h={authorsImageUrls:[void 0]},a=[{value:"In this post, I will explain how the Sudo module is used to access permissioned functions in Substrate.",id:"in-this-post-i-will-explain-how-the-sudo-module-is-used-to-access-permissioned-functions-in-substrate",level:5},{value:"What is Sudo?",id:"what-is-sudo",level:2},{value:"The Sudo Module",id:"the-sudo-module",level:2},{value:"The Sudo Key",id:"the-sudo-key",level:3},{value:"The Sudo Module Functions",id:"the-sudo-module-functions",level:3},{value:"Privileged Functions",id:"privileged-functions",level:2},{value:"A Substrate Runtime Upgrade",id:"a-substrate-runtime-upgrade",level:2},{value:"Initializing the Sudo key",id:"initializing-the-sudo-key",level:2},{value:"The End",id:"the-end",level:2}];function c(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h5:"h5",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h5,{id:"in-this-post-i-will-explain-how-the-sudo-module-is-used-to-access-permissioned-functions-in-substrate",children:"In this post, I will explain how the Sudo module is used to access permissioned functions in Substrate."}),"\n",(0,n.jsx)(t.p,{children:'If you have ever run a local Substrate node for testing or development, you have probably interacted with the Sudo module. More specifically, you might have noticed that the "Alice" account is special, and can do powerful things to your blockchain!'}),"\n",(0,n.jsx)(t.p,{children:'In this blog post, I will show you end to end how the Sudo module works, why "Alice" is able to use this module, and how it enables access to permissioned functions like the one which enables Substrate runtime upgrades.'}),"\n",(0,n.jsx)(t.h2,{id:"what-is-sudo",children:"What is Sudo?"}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"sudo"})," is a program for Unix-like computer operating systems that allows users to run programs with the security privileges of another user, by default the ",(0,n.jsx)(t.strong,{children:"superuser"}),'. It originally stood for "superuser do"...']}),"\n",(0,n.jsxs)(t.p,{children:["-- ",(0,n.jsx)("cite",{children:"Wikipedia"})]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["In short, ",(0,n.jsx)(t.code,{children:"sudo"})," is a term used to represent the execution of some highly privileged operation by some highly privileged user. If you are trying to relate this to smart contracts on Ethereum, this is very similar to ",(0,n.jsx)(t.a,{href:"https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol",children:'the "contract owner"'}),", an account who is allowed to call ",(0,n.jsx)(t.code,{children:"onlyOwner"})," functions."]}),"\n",(0,n.jsx)(t.h2,{id:"the-sudo-module",children:"The Sudo Module"}),"\n",(0,n.jsxs)(t.p,{children:["The Substrate runtime module library (SRML) provides a Sudo module which provides this same functionality, but at the runtime level of your blockchain. At the time of writing this post, the Sudo module is ",(0,n.jsx)(t.a,{href:"https://github.com/paritytech/substrate/blob/v1.0/srml/sudo/src/lib.rs",children:"only 60 lines of code"}),", so you can easily look through the source code yourself to understand exactly what it does. But I will break it down for you just in case you are unfamiliar with the structure of Runtime modules."]}),"\n",(0,n.jsx)(t.h3,{id:"the-sudo-key",children:"The Sudo Key"}),"\n",(0,n.jsx)(t.p,{children:'The Sudo module has a single storage item: the "Sudo key".'}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"decl_storage! {\n\ttrait Store for Module<T: Trait> as Sudo {\n\t\t/// The `AccountId` of the sudo key.\n\t\tKey get(key) config(): T::AccountId;\n\t}\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["This holds the ",(0,n.jsx)(t.code,{children:"AccountId"}),' of the person who is the "superuser" of your blockchain. Notice that it has the ',(0,n.jsx)(t.code,{children:"config()"}),' parameter, which means that this value can be set using the "genesis configuration" of your blockchain. We will talk about that more below.']}),"\n",(0,n.jsx)(t.h3,{id:"the-sudo-module-functions",children:"The Sudo Module Functions"}),"\n",(0,n.jsx)(t.p,{children:"The Sudo module has two dispatchable functions which allow users to interact with the module."}),"\n",(0,n.jsxs)(t.p,{children:["The first function available in the Sudo module is ",(0,n.jsx)(t.code,{children:"set_key(origin, new)"}),", which allows only the Sudo key to change who the Sudo key is. This is not that interesting, so we won't go into details."]}),"\n",(0,n.jsxs)(t.p,{children:["The second function is ",(0,n.jsx)(t.code,{children:"sudo(origin, proposal)"}),", which allows only the Sudo key to dispatch a privileged call. This authorization check is done in the first two lines of the function:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:'let sender = ensure_signed(origin)?;\nensure!(sender == Self::key(), "only the current sudo key can sudo");\n'})}),"\n",(0,n.jsx)(t.p,{children:"Then the function dispatches actually happens:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"let ok = proposal.dispatch(system::RawOrigin::Root.into()).is_ok();\n"})}),"\n",(0,n.jsx)(t.p,{children:"There are a few different things to note about this innocuous line:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["The ",(0,n.jsx)(t.code,{children:"proposal"})," variable is another dispatchable function within your runtime, and is accepted as an input to the ",(0,n.jsx)(t.code,{children:"sudo"})," function."]}),"\n",(0,n.jsxs)(t.li,{children:["This ",(0,n.jsx)(t.code,{children:"proposal"})," is called using ",(0,n.jsx)(t.code,{children:"system::RawOrigin::Root"}),", which defines the ",(0,n.jsx)(t.em,{children:"new"})," origin for the downstream call."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:['At this point, you might be asking "What does this whole ',(0,n.jsx)(t.code,{children:"RawOrigin::Root"}),' mean?"']}),"\n",(0,n.jsx)(t.h2,{id:"privileged-functions",children:"Privileged Functions"}),"\n",(0,n.jsx)(t.p,{children:'The Sudo module wouldn\'t do much unless there were also "sudo-able" functions, and that is precisely what we will talk about next.'}),"\n",(0,n.jsxs)(t.p,{children:['Substrate has the concept of "Privileged Functions" which are functions which specifically require ',(0,n.jsx)(t.code,{children:"Root"})," origin. The ",(0,n.jsx)(t.code,{children:"origin"})," of a call describes where the call has come from, and every dispatchable function should check at the beginning of the function that the call origin matches what is expected. The origin could be ",(0,n.jsx)(t.code,{children:"Signed"})," as it was in the Sudo module, which represents a basic signed transaction, but Substrate also provides a ",(0,n.jsx)(t.code,{children:"Root"})," origin which describes a call that comes from ",(0,n.jsx)(t.em,{children:"within"})," the runtime itself. There is no way to produce a ",(0,n.jsx)(t.code,{children:"Root"})," origin other than through internal runtime logic, and as such, we can treat functions that require this origin as privileged functions."]}),"\n",(0,n.jsx)(t.p,{children:"This is what a privileged function look like:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"decl_module! {\n    pub struct Module<T: Trait> for enum Call where origin: T::Origin {\n        pub fn privileged_function(origin) -> Result {\n            ensure_root(origin)?;\n            // do something...\n            Ok(())\n        }\n    }\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["However, macro magic makes this a bit more confusing. Generally, there is a rule for dispatchable functions where the first parameter must always be ",(0,n.jsx)(t.code,{children:"origin"}),". However, when using the ",(0,n.jsx)(t.code,{children:"decl_module!"})," macro, if you omit the ",(0,n.jsx)(t.code,{children:"origin"})," parameter, then it will be added automatically, and ",(0,n.jsx)(t.code,{children:"ensure_root(origin)?"})," will also be added. So an equivalent way to write the ",(0,n.jsx)(t.code,{children:"privileged_function"})," above would be:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"pub fn privileged_function() -> Result {\n    // do something...\n    Ok(())\n}\n"})}),"\n",(0,n.jsx)(t.p,{children:"So these kinds of functions will only be callable by internal runtime logic like what is implemented in the Sudo module."}),"\n",(0,n.jsx)(t.h2,{id:"a-substrate-runtime-upgrade",children:"A Substrate Runtime Upgrade"}),"\n",(0,n.jsxs)(t.p,{children:["So let's take a look at a real privileged function which is available within all Substrate runtimes, the runtime upgrade. From the ",(0,n.jsx)(t.a,{href:"https://github.com/paritytech/substrate/blob/v1.0/srml/system/src/lib.rs",children:"System module"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"/// Set the new code.\npub fn set_code(new: Vec<u8>) {\n    storage::unhashed::put_raw(well_known_keys::CODE, &new);\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:['This single line of logic is enough to power the entire "upgrade" feature of Substrate forkless runtime upgrades. This privileged function checks that the caller must have ',(0,n.jsx)(t.code,{children:"Root"})," origin, thanks to the ",(0,n.jsx)(t.code,{children:"decl_module!"})," macro, then it puts the Wasm bytecode into a ",(0,n.jsx)(t.code,{children:"well_known_key"})," called ",(0,n.jsx)(t.code,{children:"CODE"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"Thus, when you use something like the Polkadot UI to do a runtime upgrade, it will look like this:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:i(51046).Z+"",width:"2108",height:"966"})}),"\n",(0,n.jsx)(t.p,{children:"Walking through the UI you will see that:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:'We are making a transaction using "Alice", who has been set as the Sudo key.'}),"\n",(0,n.jsxs)(t.li,{children:["We are calling the ",(0,n.jsx)(t.code,{children:"sudo"})," function of the Sudo module."]}),"\n",(0,n.jsxs)(t.li,{children:["The proposal we are making is the ",(0,n.jsx)(t.code,{children:"setCode"})," function of the Consensus module."]}),"\n",(0,n.jsxs)(t.li,{children:["Of which the input to ",(0,n.jsx)(t.code,{children:"setCode"})," is the ",(0,n.jsx)(t.code,{children:"wasm"})," file for our new runtime."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"When this transaction is dispatched, the following logic is executed:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["The ",(0,n.jsx)(t.code,{children:"sudo"}),' function checks that "Alice" is the Sudo key.']}),"\n",(0,n.jsx)(t.li,{children:"She is, so the rest of the function runs."}),"\n",(0,n.jsxs)(t.li,{children:["A ",(0,n.jsx)(t.code,{children:"Root"})," origin call is dispatched to the ",(0,n.jsx)(t.code,{children:"setCode"})," function."]}),"\n",(0,n.jsxs)(t.li,{children:["The ",(0,n.jsx)(t.code,{children:"setCode"})," function checks that the origin is ",(0,n.jsx)(t.code,{children:"Root"}),"."]}),"\n",(0,n.jsx)(t.li,{children:"It is, so the rest of the function runs."}),"\n",(0,n.jsxs)(t.li,{children:["The storage value is updated for the ",(0,n.jsx)(t.code,{children:"CODE"})," well known key."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:'And that is the magic of the Sudo module! The last thing we should probably talk about is how "Alice" became the Sudo module to begin with, and for that we need to look at the genesis configuration of our blockchain.'}),"\n",(0,n.jsx)(t.h2,{id:"initializing-the-sudo-key",children:"Initializing the Sudo key"}),"\n",(0,n.jsxs)(t.p,{children:['Have you wondered why your substrate test network gives "Alice" a bunch of initial "balance units" and makes her the Sudo key for your runtime? Well, this is all controlled in your blockchain genesis configuration which is defined in a file called ',(0,n.jsx)(t.a,{href:"https://github.com/paritytech/substrate/blob/v1.0/node-template/src/chain_spec.rs",children:(0,n.jsx)(t.code,{children:"chain_spec.rs"})}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["We can see that this code ultimately creates a ",(0,n.jsx)(t.code,{children:"GenesisConfig"})," object with the following initial setting:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"sudo: Some(SudoConfig {\n    key: root_key,\n}),\n"})}),"\n",(0,n.jsxs)(t.p,{children:["If we follow the logic back, this ",(0,n.jsx)(t.code,{children:"root_key"})," is defined as ",(0,n.jsx)(t.code,{children:'account_key("Alice")'})," which generates an ",(0,n.jsx)(t.code,{children:"AccountId"}),' using the seed string "Alice".']}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:'fn account_key(s: &str) -> AccountId {\n    sr25519::Pair::from_string(&format!("//{}", s), None)\n        .expect("static values are valid; qed")\n        .public()\n}\n'})}),"\n",(0,n.jsxs)(t.p,{children:['This works great for test networks since "Alice" can be treated as a well known account that is automatically configured in your UI. However, for a real network, this is probably not what you want to do. Instead, you should pass an ',(0,n.jsx)(t.code,{children:"AccountId"})," directly to this genesis configuration, and keep the seed for this account VERY secret."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:i(87392).Z+"",width:"1230",height:"416"})}),"\n",(0,n.jsx)(t.h2,{id:"the-end",children:"The End"}),"\n",(0,n.jsx)(t.p,{children:"That is the entire sudo story in Substrate. I hope you learned something new and that this shed light to some of the things happening behind the scenes of Substrate runtimes."}),"\n",(0,n.jsxs)(t.p,{children:["If you enjoyed this content and want to support me producing more, feel free to check out my ",(0,n.jsx)(t.a,{href:"https://shawntabrizi.com/donate/",children:"donation page"}),"."]})]})}function d(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},51046:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/img_5ccc8f228649c-0cc67199b8c5cbc0db31211ea72d25af.png"},87392:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/img_5ccc92f09f522-7517ff126dc6e4788610fd73a96f9d43.png"},11151:(e,t,i)=>{i.d(t,{Z:()=>l,a:()=>r});var n=i(67294);const s={},o=n.createContext(s);function r(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);