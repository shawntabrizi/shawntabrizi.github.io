"use strict";(self.webpackChunkshawntabrizi=self.webpackChunkshawntabrizi||[]).push([[81471],{10563:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var s=n(85893),i=n(11151);const a={title:"Adding Fees to Your Substrate Runtime Module",date:new Date("2019-05-27T00:00:00.000Z"),authors:"shawntabrizi",slug:"/substrate/adding-fees-to-your-substrate-runtime-module/",categories:["Substrate"],tags:["runtime","module","rust","fees","balance","ethereum"]},o=void 0,r={permalink:"/blog/substrate/adding-fees-to-your-substrate-runtime-module/",source:"@site/blog/2019-05-27-adding-fees-to-your-substrate-runtime-module.md",title:"Adding Fees to Your Substrate Runtime Module",description:"In this post, I will show you how you can easily add a fee for calling a function within your Substrate runtime module.",date:"2019-05-27T00:00:00.000Z",formattedDate:"May 27, 2019",tags:[{label:"runtime",permalink:"/blog/tags/runtime"},{label:"module",permalink:"/blog/tags/module"},{label:"rust",permalink:"/blog/tags/rust"},{label:"fees",permalink:"/blog/tags/fees"},{label:"balance",permalink:"/blog/tags/balance"},{label:"ethereum",permalink:"/blog/tags/ethereum"}],readingTime:7.99,hasTruncateMarker:!1,authors:[{name:"Shawn Tabrizi",title:"Software Engineer",url:"https://github.com/shawntabrizi",imageURL:"https://github.com/shawntabrizi.png",key:"shawntabrizi"}],frontMatter:{title:"Adding Fees to Your Substrate Runtime Module",date:"2019-05-27T00:00:00.000Z",authors:"shawntabrizi",slug:"/substrate/adding-fees-to-your-substrate-runtime-module/",categories:["Substrate"],tags:["runtime","module","rust","fees","balance","ethereum"]},unlisted:!1,prevItem:{title:"Extending Substrate Runtime Modules",permalink:"/blog/substrate/extending-substrate-runtime-modules/"},nextItem:{title:"Substrate Smart Contracts Workshop",permalink:"/blog/substrate/substrate-smart-contracts-workshop/"}},l={authorsImageUrls:[void 0]},c=[{value:"In this post, I will show you how you can easily add a fee for calling a function within your Substrate runtime module.",id:"in-this-post-i-will-show-you-how-you-can-easily-add-a-fee-for-calling-a-function-within-your-substrate-runtime-module",level:5},{value:"A Simple Fee",id:"a-simple-fee",level:2},{value:"Withdrawing From Balance",id:"withdrawing-from-balance",level:3},{value:"Imbalance",id:"imbalance",level:4},{value:"Charging a Fee",id:"charging-a-fee",level:3},{value:"Converting Rust Primitives to Substrate Specific Types",id:"converting-rust-primitives-to-substrate-specific-types",level:4},{value:"A Minimal, Complete, Verifiable Example Module",id:"a-minimal-complete-verifiable-example-module",level:2},{value:"Next Steps",id:"next-steps",level:2}];function u(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",h5:"h5",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h5,{id:"in-this-post-i-will-show-you-how-you-can-easily-add-a-fee-for-calling-a-function-within-your-substrate-runtime-module",children:"In this post, I will show you how you can easily add a fee for calling a function within your Substrate runtime module."}),"\n",(0,s.jsx)(t.p,{children:"When using Substrate, you are afforded the flexibility to completely control the fee system within your runtime."}),"\n",(0,s.jsxs)(t.p,{children:["By default, a ",(0,s.jsx)(t.a,{href:"https://substrate.dev/rustdocs/v1.0/srml_balances/struct.Module.html#method.transaction_base_fee",children:(0,s.jsx)(t.code,{children:"transaction_base_fee"})})," is added to every transaction you make to your runtime. However, this blanket base fee does NOT take into account anything related to the complexity or storage used as a result of the transaction."]}),"\n",(0,s.jsxs)(t.p,{children:["Substrate makes the following recommendation in the ",(0,s.jsx)(t.code,{children:"Example"})," module:"]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:["Ensure that calls into each of these [functions] execute in a time, memory and using storage space ",(0,s.jsx)(t.strong,{children:"proportional to any costs paid for by the caller"})," or otherwise the difficulty of forcing the call to happen."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Thus, if your runtime module exposes functions which are heavy in computation or storage needs, you should be sure to add some ",(0,s.jsx)(t.em,{children:"additional"})," fee on top of the base fee to ensure your blockchain is not attackable."]}),"\n",(0,s.jsx)(t.h2,{id:"a-simple-fee",children:"A Simple Fee"}),"\n",(0,s.jsxs)(t.p,{children:["There are a lot of complicated methods you can use for calculating fees for functions. You can take a look at the ",(0,s.jsx)(t.a,{href:"https://github.com/paritytech/substrate/tree/v1.0/srml/contract",children:"Contract module"})," for an example of that."]}),"\n",(0,s.jsx)(t.p,{children:"For this example, I will be showing you the most simple implementation of a fee which will be inline with the rest of your module code."}),"\n",(0,s.jsx)(t.h3,{id:"withdrawing-from-balance",children:"Withdrawing From Balance"}),"\n",(0,s.jsxs)(t.p,{children:["The first tool we will use is the ",(0,s.jsxs)(t.a,{href:"https://substrate.dev/rustdocs/v1.0/srml_support/traits/trait.Currency.html#tymethod.withdraw",children:[(0,s.jsx)(t.code,{children:"withdraw"})," function"]})," provided by the ",(0,s.jsx)(t.code,{children:"Currency"})," trait in the Balances module:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"fn withdraw(\n    who: &AccountId,\n    value: Self::Balance,\n    reason: WithdrawReason,\n    liveness: ExistenceRequirement\n) -> Result<Self::NegativeImbalance, &'static str>\n"})}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:"Removes some free balance from who account for reason if possible. If liveness is KeepAlive, then no less than ExistentialDeposit must be left remaining."}),"\n",(0,s.jsx)(t.p,{children:"This checks any locks, vesting, and liquidity requirements. If the removal is not possible, then it returns Err."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Withdraw is designed to be quite flexible. As you can see, it allows you to specify the reason for a withdrawal. In this case, we are taking a ",(0,s.jsx)(t.em,{children:"fee"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"// use support::traits::WithdrawReason\nWithdrawReason::Fee\n"})}),"\n",(0,s.jsx)(t.p,{children:"It can even make sure that removing these funds will not kill an account. For our fee system, this second point will be particularly important since we do not want users to accidentally destroy their account paying for fees!"}),"\n",(0,s.jsx)(t.p,{children:"For this, we simply pass:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"// use support::traits::ExistenceRequirement\nExistenceRequirement::KeepAlive\n"})}),"\n",(0,s.jsx)(t.p,{children:"Now we can really safely charge fees to a user upfront and let the logic of the Balances module handle the rest. For ease of reusability, we will create an internal function which can be called within our module to charge a fee to a user:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"impl<T: Trait> Module<T> {\n  fn pay_fee(who: T::AccountId, amount: T::Balance) -> Result {\n    let _ = <balances::Module<T> as Currency<_>>::withdraw(\n      &who,\n      amount,\n      WithdrawReason::Fee,\n      ExistenceRequirement::KeepAlive\n    )?;\n\n    Ok(())\n  }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This function will either propagate an error from taking funds from the user, or will complete successfully and return ",(0,s.jsx)(t.code,{children:"Ok(())"}),". We can then handle the error within our runtime."]}),"\n",(0,s.jsx)(t.h4,{id:"imbalance",children:"Imbalance"}),"\n",(0,s.jsxs)(t.p,{children:["One thing we glazed over at this point is the return type of the ",(0,s.jsx)(t.code,{children:"withdraw"})," function:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"-> Result<Self::NegativeImbalance, &'static str>\n"})}),"\n",(0,s.jsxs)(t.p,{children:["As you can see, it returns a ",(0,s.jsx)(t.code,{children:"NegativeImbalance"}),", which is probably a type you have never seen before. Without going into ",(0,s.jsx)(t.em,{children:"too"})," much detail, the ",(0,s.jsx)(t.a,{href:"https://github.com/paritytech/substrate/pull/2048",children:"Imbalance system"})," within the Balances module is a way to ensure that the sum of all funds across all accounts is equal to the ",(0,s.jsx)(t.code,{children:"TotalIssuance"})," managed by the Balances module."]}),"\n",(0,s.jsxs)(t.p,{children:["So fortunately, this imbalances system ",(0,s.jsx)(t.a,{href:"https://stackoverflow.com/questions/56341343/is-handling-the-imbalance-type-mandatory-after-withdraw-or-deposit",children:"does all of the hard work for us!"})," All we need to do is ignore this return type and we can be happy that the ",(0,s.jsx)(t.code,{children:"TotalIssuance"})," is updated and this value is actually burned."]}),"\n",(0,s.jsx)(t.h3,{id:"charging-a-fee",children:"Charging a Fee"}),"\n",(0,s.jsxs)(t.p,{children:["Now that we have created our ",(0,s.jsx)(t.code,{children:"pay_fee"})," function, we need to call it within our runtime module. We will emulate a fixed fee system similar to the low level OPCODEs provided by Ethereum, where each function in our module can define some fixed cost to call the function."]}),"\n",(0,s.jsx)(t.p,{children:"This can be done easily by simply writing a function like so:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"decl_module! {\n  pub struct Module<T: Trait> for enum Call where origin: T::Origin {\n    pub fn do_something(origin) -> Result\n    {\n      let who = ensure_signed(origin)?;\n      let fee = 1337.into();\n\n      Self::pay_fee(who, fee)?;\n\n      // Do stuff after fee is paid successfully...\n\n      Ok(())\n    }\n\n  }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This function checks whether or not ",(0,s.jsx)(t.code,{children:"pay_fee"})," returns successfully, and if not, it propagates the error up and stops execution of the runtime function."]}),"\n",(0,s.jsxs)(t.p,{children:["In the situation where a user is unable to ",(0,s.jsx)(t.code,{children:"withdraw"})," funds, we will see the error message:"]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:"Runtime: too few free funds in account"}),"\n"]}),"\n",(0,s.jsx)(t.h4,{id:"converting-rust-primitives-to-substrate-specific-types",children:"Converting Rust Primitives to Substrate Specific Types"}),"\n",(0,s.jsxs)(t.p,{children:["You may notice that ",(0,s.jsx)(t.code,{children:"pay_fee"})," and ",(0,s.jsx)(t.code,{children:"withdraw"})," expect ",(0,s.jsx)(t.code,{children:"fee"})," to be of type ",(0,s.jsx)(t.code,{children:"T::Balance"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Remember that Substrate is written to be ",(0,s.jsx)(t.strong,{children:"very"})," generic, so in the context of your runtime module, there are minimal assumptions about your blockchain's types."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, using this generic type system, you would be able to define one Substrate blockchain which uses ",(0,s.jsx)(t.code,{children:"u64"})," for the ",(0,s.jsx)(t.code,{children:"Balance"})," type, another which uses ",(0,s.jsx)(t.code,{children:"u128"}),", and another which uses ",(0,s.jsx)(t.code,{children:"u32"}),". Because we use this generic type system for all the core blockchain types, the same module can be used out of the box across all of these different blockchains!"]}),"\n",(0,s.jsx)(t.p,{children:"But this flexibility also means you need to tell the Rust compiler what to do when trying to handle incompatible situations."}),"\n",(0,s.jsxs)(t.p,{children:["For example, what should the module do if we try to put a ",(0,s.jsx)(t.code,{children:"u128"})," value into a ",(0,s.jsx)(t.code,{children:"Balance"})," type which is represented as ",(0,s.jsx)(t.code,{children:"u64"}),"? Or if we try to convert that same balance to a ",(0,s.jsx)(t.code,{children:"u32"}),"?"]}),"\n",(0,s.jsxs)(t.p,{children:["Substrate ",(0,s.jsx)(t.a,{href:"https://stackoverflow.com/questions/56081117/how-do-you-convert-between-substrate-specific-types-and-rust-primitive-types",children:"provides implementations"})," of ",(0,s.jsx)(t.code,{children:"From"}),"/",(0,s.jsx)(t.code,{children:"TryFrom"})," and ",(0,s.jsx)(t.code,{children:"Into"}),"/",(0,s.jsx)(t.code,{children:"TryInto"})," to handle such scenarios. The only assumption being made here is that all values are at least a ",(0,s.jsx)(t.code,{children:"u32"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"These traits guarantee that the underlying types implement functions which will attempt to convert between types if possible."}),"\n",(0,s.jsxs)(t.p,{children:["Thus, if we ever need to convert some ",(0,s.jsx)(t.code,{children:"u32"})," value to a ",(0,s.jsx)(t.code,{children:"Balance"}),", we can simply call:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"let my_balance: T::Balance = my_u32.into();\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In the situation you need to convert some larger value, you will need to handle the situation where the ",(0,s.jsx)(t.code,{children:"Balance"})," type is not compatible with type to be converted:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"pub fn u64_to_balance(input: u64) -> Option<T::Balance> {\n    input.try_into().ok()\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Note that this returns an ",(0,s.jsx)(t.code,{children:"Option"}),", thus your subsequent runtime logic needs to decide what to do when the conversion fails and the returned value is ",(0,s.jsx)(t.code,{children:"None"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Substrate also provides a ",(0,s.jsx)(t.code,{children:"saturated_into"})," function which will always succeed, but will coerce your value into the type you want through saturation if necessary:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"pub fn u64_to_balance_saturated(input: u64) -> T::Balance {\n    input.saturated_into()\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["However, it is very important that you be conscious when you do such things. From ",(0,s.jsx)(t.a,{href:"https://twitter.com/gavofyork",children:"Gav"}),":"]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"SaturatedConversion"})," (",(0,s.jsx)(t.code,{children:"saturated_into"})," and ",(0,s.jsx)(t.code,{children:"saturated_from"}),") should not be used unless you know what you're doing, you've thought and considered all options and your use-case implies that saturation is fundamentally correct. The only time I imagine this is the case is deep in runtime arithmetic where you are logically certain it will not overflow, but can't provide a proof because it would depend on consistent pre-existing state."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Remember, as a runtime developer, Substrate provides you with numerous tools, but it is ultimately up to you to determine how to use them."}),"\n",(0,s.jsx)(t.h2,{id:"a-minimal-complete-verifiable-example-module",children:"A Minimal, Complete, Verifiable Example Module"}),"\n",(0,s.jsx)(t.p,{children:"If you want to try out this simple fee system on your own Substrate chain, you can simply add a module like this to your runtime:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"use support::{decl_module, dispatch::Result,\n  traits::{Currency, ExistenceRequirement, WithdrawReason}};\nuse system::ensure_signed;\n\n// v1.0 branch\n// use runtime_primitives::traits::As;\n\npub trait Trait: balances::Trait {}\n\ndecl_module! {\n  pub struct Module<T: Trait> for enum Call where origin: T::Origin {\n    pub fn do_something(origin) -> Result\n    {\n      let who = ensure_signed(origin)?;\n\n      let fee = 1337.into();\n      // v1.0 branch\n      // let fee = T::Balance::sa(1337);\n\n      Self::pay_fee(who, fee)?;\n\n      // Do stuff after fee is paid successfully...\n\n      Ok(())\n    }\n\n  }\n}\n\nimpl<T: Trait> Module<T> {\n  fn pay_fee(who: T::AccountId, amount: T::Balance) -> Result {\n    let _ = <balances::Module<T> as Currency<_>>::withdraw(\n      &who,\n      amount,\n      WithdrawReason::Fee,\n      ExistenceRequirement::KeepAlive\n    )?;\n\n    Ok(())\n  }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["If we run a local node, we can interact with the module through the ",(0,s.jsx)(t.a,{href:"https://polkadot.js.org/apps/",children:"Polkadot UI"}),":"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Image of Extrinsic Tab",src:n(29890).Z+"",width:"2476",height:"1500"})}),"\n",(0,s.jsx)(t.p,{children:"We have funded the Bob account with 2000 units, and we are charging a fee of 1337. When we call our function the first time, everything works as expected, and the 1337 unit fee (in addition to the base transaction fee of 1 unit) is removed from the account."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Image of Fee Success",src:n(92537).Z+"",width:"2476",height:"1500"})}),"\n",(0,s.jsx)(t.p,{children:"However, when Bob does not have enough funds to make a second call, they will see a failure message:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Image of Fee Failure",src:n(9351).Z+"",width:"2476",height:"1500"})}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:"Note though that the 1 unit base transaction fee was still removed."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"If we look at our local node terminal, we can see the reason why this transaction failed:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Image of Fee Error",src:n(85802).Z+"",width:"1512",height:"536"})}),"\n",(0,s.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsx)(t.p,{children:"As mentioned, this is a very minimal and simplistic implementation of a fee system. However, this should give you the tools necessary to build your own advance fee system. Here are some cool ideas:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Create some authorization layer where certain users get lower fees than the average user."}),"\n",(0,s.jsx)(t.li,{children:"Allow fees to be paid using other tokens that your runtime manages."}),"\n",(0,s.jsxs)(t.li,{children:["Have your fee be calculated based on any input from the user. For example, if you let the user store some ",(0,s.jsx)(t.code,{children:"Vec<u8>"}),", you can charge them some linear cost based on the length of the data."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Do you have other ideas? Let me know!"}),"\n",(0,s.jsxs)(t.p,{children:["As always, if you enjoy my content, take a quick look at my ",(0,s.jsx)(t.a,{href:"https://shawntabrizi.com/donate/",children:"donation page"})," to help support future work."]})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},85802:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/substrate-fee-error-b0332c67341e4562a0d0812e865054f8.png"},29890:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/substrate-fee-extrinsic-044a3070a671072882b287f968ad9f2e.png"},9351:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/substrate-fee-fail-23d785fb776c8d3da0d50b0df6ae9b26.png"},92537:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/substrate-fee-success-8bcf960f460759e6886e9be4ac99074a.png"},11151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>o});var s=n(67294);const i={},a=s.createContext(i);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);