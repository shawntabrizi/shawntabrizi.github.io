"use strict";(self.webpackChunkshawntabrizi=self.webpackChunkshawntabrizi||[]).push([[6559],{25892:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>h});var o=n(85893),i=n(11151);const a={title:"Substrate Weights and Fees",date:new Date("2020-02-27T00:00:00.000Z"),authors:"shawntabrizi",slug:"/substrate/substrate-weight-and-fees/",categories:["Substrate"],tags:["weight","transaction","fee","benchmark","substrate"]},s=void 0,r={permalink:"/blog/substrate/substrate-weight-and-fees/",source:"@site/blog/2020-02-27-substrate-weights-and-fees.md",title:"Substrate Weights and Fees",description:"This is the first in a series of posts explaining our philosophy toward benchmarking and assigning weights to Substrate pallets for the imminent launch of the Polkadot network.",date:"2020-02-27T00:00:00.000Z",tags:[{inline:!0,label:"weight",permalink:"/blog/tags/weight"},{inline:!0,label:"transaction",permalink:"/blog/tags/transaction"},{inline:!0,label:"fee",permalink:"/blog/tags/fee"},{inline:!0,label:"benchmark",permalink:"/blog/tags/benchmark"},{inline:!0,label:"substrate",permalink:"/blog/tags/substrate"}],readingTime:7.275,hasTruncateMarker:!1,authors:[{name:"Shawn Tabrizi",title:"Software Engineer",url:"https://github.com/shawntabrizi",imageURL:"https://github.com/shawntabrizi.png",key:"shawntabrizi"}],frontMatter:{title:"Substrate Weights and Fees",date:"2020-02-27T00:00:00.000Z",authors:"shawntabrizi",slug:"/substrate/substrate-weight-and-fees/",categories:["Substrate"],tags:["weight","transaction","fee","benchmark","substrate"]},unlisted:!1,prevItem:{title:"Transparent Keys in Substrate",permalink:"/blog/substrate/transparent-keys-in-substrate/"},nextItem:{title:"Porting Web3.js to Polkadot.js",permalink:"/blog/substrate/porting-web3-js-to-polkadot-js/"}},l={authorsImageUrls:[void 0]},h=[{value:"This is the first in a series of posts explaining our philosophy toward benchmarking and assigning weights to Substrate pallets for the imminent launch of the Polkadot network.",id:"this-is-the-first-in-a-series-of-posts-explaining-our-philosophy-toward-benchmarking-and-assigning-weights-to-substrate-pallets-for-the-imminent-launch-of-the-polkadot-network",level:5},{value:"Weights",id:"weights",level:2},{value:"Example",id:"example",level:3},{value:"Fees",id:"fees",level:2},{value:"Runtime Development",id:"runtime-development",level:2},{value:"Documentation of Weights",id:"documentation-of-weights",level:3},{value:"What to Document",id:"what-to-document",level:4},{value:"Storage and Codec Operations",id:"storage-and-codec-operations",level:4},{value:"Search, Sort, and Notable Computations",id:"search-sort-and-notable-computations",level:4},{value:"Calls to Other Pallets and Traits",id:"calls-to-other-pallets-and-traits",level:4},{value:"Combining the Data",id:"combining-the-data",level:4},{value:"Summary",id:"summary",level:2}];function c(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h5,{id:"this-is-the-first-in-a-series-of-posts-explaining-our-philosophy-toward-benchmarking-and-assigning-weights-to-substrate-pallets-for-the-imminent-launch-of-the-polkadot-network",children:"This is the first in a series of posts explaining our philosophy toward benchmarking and assigning weights to Substrate pallets for the imminent launch of the Polkadot network."}),"\n",(0,o.jsx)(t.p,{children:"For the past couple of weeks, I have been working hard creating and executing a plan around weighing extrinsic functions across our different FRAME pallets so that we can launch the Polkadot network."}),"\n",(0,o.jsx)(t.p,{children:"There are a few overall goals that we want to accomplish with this task:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Provide computational limits and thresholds for block producers on the network."}),"\n",(0,o.jsx)(t.li,{children:"Provide economic security such that malicious actors would not be able to profitably attack the network."}),"\n",(0,o.jsx)(t.li,{children:"Identify and redesign extrinsics which have non-linear complexity."}),"\n",(0,o.jsx)(t.li,{children:"Improve the runtime architecture to reduce overall complexity."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:'To follow along this journey, you must first understand what "weights" are in Substrate, and how they are related to the more commonly understood fee system.'}),"\n",(0,o.jsx)(t.h2,{id:"weights",children:"Weights"}),"\n",(0,o.jsxs)(t.p,{children:["If you are unfamiliar with weights, the TL;DR is that a Substrate blockchains have limited resources when it comes to producing new blocks. Most notably, there is a limited window for block producers to create a block, limited amount of data that can be included per block (",(0,o.jsx)(t.a,{href:"https://substrate.dev/rustdocs/master/frame_system/trait.Trait.html#associatedtype.MaximumBlockLength",children:(0,o.jsx)(t.code,{children:"MaximumBlockLength"})}),"), and an overall practical limit to the storage footprint of the blockchain."]}),"\n",(0,o.jsxs)(t.p,{children:['Substrate has introduced a Weight system that allows the runtime developer to tell the block production process how "heavy" an extrinsic is. Given some ',(0,o.jsx)(t.a,{href:"https://substrate.dev/rustdocs/master/frame_system/trait.Trait.html#associatedtype.MaximumBlockWeight",children:(0,o.jsx)(t.code,{children:"MaximumBlockWeight"})}),", and the weight of the individual extrinsics in a transaction pool, we can select the set of extrinsics that allow us to saturate our block, while not going over the limits."]}),"\n",(0,o.jsxs)(t.p,{children:["On top of this basic idea, Substrate has additionally introduced a configurable ",(0,o.jsx)(t.a,{href:"https://substrate.dev/rustdocs/master/frame_system/trait.Trait.html#associatedtype.AvailableBlockRatio",children:(0,o.jsx)(t.code,{children:"AvailableBlockRatio"})})," which ensures that only a portion of the total ",(0,o.jsx)(t.code,{children:"MaximumBlockWeight"})," is used for regular transactions. This also introduces the concept of ",(0,o.jsx)(t.em,{children:"operational transactions"})," which are system critical operations that can use the rest of the available block weight."]}),"\n",(0,o.jsx)(t.h3,{id:"example",children:"Example"}),"\n",(0,o.jsxs)(t.p,{children:["Let's say a ",(0,o.jsx)(t.code,{children:"balance_transfer"})," has weight 1,000, and our Substrate chain is configured to a maximum block weight of 1,000,000, with an available block ratio of 20%."]}),"\n",(0,o.jsx)(t.p,{children:"This means we would be able to include at most:"}),"\n",(0,o.jsx)(t.p,{children:"1,000,000 * .20 / 1,000 = 200 transfers per block"}),"\n",(0,o.jsxs)(t.p,{children:["For more details on weights, read our doc: ",(0,o.jsx)(t.a,{href:"https://substrate.dev/docs/en/conceptual/runtime/weight",children:"https://substrate.dev/docs/en/conceptual/runtime/weight"})]}),"\n",(0,o.jsx)(t.h2,{id:"fees",children:"Fees"}),"\n",(0,o.jsx)(t.p,{children:"To bring the weight system to the users of our blockchain, Substrate introduces a tightly coupled fee system. In short, users will pay a transaction fee proportional to the weight of the call they are making."}),"\n",(0,o.jsx)(t.p,{children:"total_fee = base_fee + length_fee + weight_fee"}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"Note: There is also a length_fee which takes into account the amount of data included in an extrinsic."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"As a pallet developer writing new dispatchable functions, the fee system should mostly be abstract to you, and instead you should primarily think in terms of weights."}),"\n",(0,o.jsxs)(t.p,{children:["For more details on fees, read our doc: ",(0,o.jsx)(t.a,{href:"https://substrate.dev/docs/en/development/module/fees",children:"https://substrate.dev/docs/en/development/module/fees"})]}),"\n",(0,o.jsx)(t.h2,{id:"runtime-development",children:"Runtime Development"}),"\n",(0,o.jsx)(t.p,{children:"As a runtime developer, it is your goal to:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Minimize the computational and resource complexity of runtime functions."}),"\n",(0,o.jsx)(t.li,{children:"Accurately calculate the relative weight of your runtime functions."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"We can accomplish this in three steps:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Follow best practices when writing a runtime."}),"\n",(0,o.jsx)(t.li,{children:"Accurately document the computational complexity introduced by runtime functions."}),"\n",(0,o.jsx)(t.li,{children:"Empirically measure the real world cost of running these functions, and associate those measurements back to our computational complexity."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"It is beyond the scope of any single blog post to explain all the best practices when it comes to runtime development, but we can start to touch on (2) and follow up and talk more about how to approach (3)."}),"\n",(0,o.jsx)(t.h3,{id:"documentation-of-weights",children:"Documentation of Weights"}),"\n",(0,o.jsxs)(t.p,{children:["Dispatchable functions within a FRAME pallet should contain documentation about the computational and resource complexity of the function. The result of weight documentation is to arrive at a final ",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Big_O_notation",children:"order of a function"}),". Such as:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"O(A + logA + BlogC)\n"})}),"\n",(0,o.jsx)(t.p,{children:"This should serve as a resource to accurately measure the weight of different functions across all possible inputs, something we would not reasonably able to measure otherwise."}),"\n",(0,o.jsx)(t.h4,{id:"what-to-document",children:"What to Document"}),"\n",(0,o.jsx)(t.p,{children:"Your weight documentation should include information about your runtime function which has notable execution costs. For example:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Storage Operations (read, write, mutate, etc...)"}),"\n",(0,o.jsx)(t.li,{children:"Codec Operations (serializing/deserializing vecs or large structs)"}),"\n",(0,o.jsx)(t.li,{children:"Search / Sort / Notable Computation"}),"\n",(0,o.jsx)(t.li,{children:"Calls to other pallet functions (i.e. reserving some balance through the Currency trait)"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"We will work off the following example function:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-rust",children:'// Join a group of members.\nfn join(origin) {\n\tlet who = ensure_signed(origin)?;\n\tlet deposit = T::Deposit::get(); // configuration constant\n\tlet sorted_members: Vec<T::AccountId> = Self::members();\n\tensure!(sorted_members.len() <= 100, "Membership Full");\n\tmatch sorted_members.binary_search(&who) {\n\t\t// User is not a member.\n\t\tErr(i) => {\n\t\t\tT::Currency::reserve(&who, deposit)?;\n\t\t\tmembers.insert(i, who.clone());\n\t\t\t<Members<T>>::put(sorted_members);\n\t\t\tOk(())\n\t\t},\n\t\t// User is already a member, do nothing.\n\t\tOk(_) => Ok(()),\n\t}\n\tSelf::deposit_event(RawEvent::Joined(who));\n}\n'})}),"\n",(0,o.jsx)(t.h4,{id:"storage-and-codec-operations",children:"Storage and Codec Operations"}),"\n",(0,o.jsxs)(t.p,{children:['Accessing storage is a heavy operation, and one that should be well documented and optimized in favor writing "functional code". See ',(0,o.jsx)(t.a,{href:"https://www.notion.so/paritytechnologies/Weights-8c916536949b47f299eed1302b6a2074?p=c5aafd34578f4be9ab8c8d7510e98314&showMoveTo=true#best-practices",children:"Best Practices"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"The each storage operation should be documented with the relative codec complexity of interacting with that storage."}),"\n",(0,o.jsx)(t.p,{children:"For example, if you are reading a vector of members from a single value storage item, the weight documentation should read:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["One storage read to get the members of this pallet: ",(0,o.jsx)(t.code,{children:"O(M)"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["In this case reading the vector from storage has a codec complexity of ",(0,o.jsx)(t.code,{children:"O(M)"})," to deserialize the ",(0,o.jsx)(t.code,{children:"M"})," member accounts in the vector."]}),"\n",(0,o.jsx)(t.p,{children:"Later in your module, you might go ahead and write the data back into the runtime, which should also be documented:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["One storage write to update the members of this pallet: ",(0,o.jsx)(t.code,{children:"O(M)"}),"."]}),"\n"]}),"\n",(0,o.jsx)(t.h4,{id:"search-sort-and-notable-computations",children:"Search, Sort, and Notable Computations"}),"\n",(0,o.jsx)(t.p,{children:"If you need to search or sort in your runtime module, it is also important to note the relative complexity of those operations."}),"\n",(0,o.jsxs)(t.p,{children:["For example, if you are searching for an item in a sorted list, a ",(0,o.jsx)(t.code,{children:"binary_search"})," operation should take ",(0,o.jsx)(t.code,{children:"O(logM)"}),", while an unsorted list, should take ",(0,o.jsx)(t.code,{children:"O(M)"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"So the documentation may look like:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Insert a new member into sorted list: O(logM)."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"This kind of documentation should be present for any sort of notable heavy computation present in your logic."}),"\n",(0,o.jsx)(t.h4,{id:"calls-to-other-pallets-and-traits",children:"Calls to Other Pallets and Traits"}),"\n",(0,o.jsx)(t.p,{children:"The computational complexity of your function may extend beyond your pallet. If you call other FRAME pallets either directly or through Trait configurations, you should take note of that, and assign these calls with their own variable."}),"\n",(0,o.jsx)(t.p,{children:"For example, if you write a function which reserves some balance in the Balances pallet or emits an event through the System pallet, you should document:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"One balance reserve operation: O(B)"}),"\n",(0,o.jsx)(t.li,{children:"One event emitted: O(E)"}),"\n"]}),"\n",(0,o.jsx)(t.h4,{id:"combining-the-data",children:"Combining the Data"}),"\n",(0,o.jsxs)(t.p,{children:["Once you have good documentation for your runtime function, you need to consolidate it into a ",(0,o.jsx)(t.em,{children:"single overall order of the function"}),".Lets combine the different example operations to create a full end to end example."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-text",children:"# <weight>\nKey: M (len of members), B (reserve balance), E (event)\n- One storage read to get the members of this pallet: `O(M)`.\n- One balance reserve operation: O(B)\n- Insert a new member into sorted list: O(logM).\n- One storage write to update the members of this pallet: `O(M)`.\n- One event emitted: O(E)\n\nTotal Complexity: O(M + logM + B + E)\n# </weight>\n"})}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"Note: You may have introduced multiple different variables into your overall weight documentation, so be sure to document what these variables represent."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"If you look at this example, you can see we had two operations that were O(M) (the storage read and write), but our overall order does not take this into account."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"When doing empirical testing, we are unable to separate complexities which have the same order"}),". This means that there could be many many more operations added to this function, of order ",(0,o.jsx)(t.code,{children:"O(M)"}),", ",(0,o.jsx)(t.code,{children:"O(logM"}),"), etc.. but it would not change our final formula as a function of ",(0,o.jsx)(t.code,{children:"M"}),", ",(0,o.jsx)(t.code,{children:"B"}),", and ",(0,o.jsx)(t.code,{children:"E"}),":"]}),"\n",(0,o.jsx)(t.p,{children:"weight(M, B, E) = K_1 + K_2 * M + K_3 * logM + B + E"}),"\n",(0,o.jsxs)(t.p,{children:["The difference between two functions with the same order will be empirically measured through on-chain tests. The goal of this step is to simply derive the coefficients (",(0,o.jsx)(t.code,{children:"K"}),") that we will be searching for when we do the ",(0,o.jsx)(t.a,{href:"https://www.notion.so/paritytechnologies/Weights-8c916536949b47f299eed1302b6a2074?p=c5aafd34578f4be9ab8c8d7510e98314&showMoveTo=true#measuring-weights",children:"next step"}),"."]}),"\n",(0,o.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(t.p,{children:"So hopefully now you can see how we can approach runtime code, and from it, derive a theoretical order of complexity. The next step after this is to actually run benchmarks for these different extrinsics, and start collecting data that we can map back to these derived formulas."}),"\n",(0,o.jsxs)(t.p,{children:["If you enjoy this content and want to see the next post where we dive deeper into actually benchmarking the runtime, consider taking a look at my ",(0,o.jsx)(t.a,{href:"https://shawntabrizi.com/donate/",children:"donations page"})," to see how you can support me."]})]})}function d(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>s});var o=n(67294);const i={},a=o.createContext(i);function s(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(a.Provider,{value:t},e.children)}}}]);