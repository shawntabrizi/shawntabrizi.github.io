"use strict";(self.webpackChunkshawntabrizi=self.webpackChunkshawntabrizi||[]).push([[6684],{66803:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>h});var i=n(85893),o=n(11151);const a={title:"Getting Twitter posts for Ethereum using an Oracle",date:new Date("2018-08-27T05:16:09.000Z"),authors:"shawntabrizi",slug:"/ethereum/getting-twitter-posts-for-ethereum-using-an-oracle/",categories:["Ethereum"],tags:["blockchain","ethereum","oraclize","programming","smart contract","solidity","twitter"],github:"Ethereum-Twitter-Bounty"},r=void 0,s={permalink:"/blog/ethereum/getting-twitter-posts-for-ethereum-using-an-oracle/",source:"@site/blog/2018-08-26-getting-twitter-posts-for-ethereum-using-an-oracle.md",title:"Getting Twitter posts for Ethereum using an Oracle",description:"This post will show you how to use the Oraclize.it blockchain oracle to get and store Twitter posts for Ethereum smart contracts.",date:"2018-08-27T05:16:09.000Z",tags:[{inline:!0,label:"blockchain",permalink:"/blog/tags/blockchain"},{inline:!0,label:"ethereum",permalink:"/blog/tags/ethereum"},{inline:!0,label:"oraclize",permalink:"/blog/tags/oraclize"},{inline:!0,label:"programming",permalink:"/blog/tags/programming"},{inline:!0,label:"smart contract",permalink:"/blog/tags/smart-contract"},{inline:!0,label:"solidity",permalink:"/blog/tags/solidity"},{inline:!0,label:"twitter",permalink:"/blog/tags/twitter"}],readingTime:7.415,hasTruncateMarker:!1,authors:[{name:"Shawn Tabrizi",title:"Software Engineer",url:"https://github.com/shawntabrizi",imageURL:"https://github.com/shawntabrizi.png",key:"shawntabrizi",page:null}],frontMatter:{title:"Getting Twitter posts for Ethereum using an Oracle",date:"2018-08-27T05:16:09.000Z",authors:"shawntabrizi",slug:"/ethereum/getting-twitter-posts-for-ethereum-using-an-oracle/",categories:["Ethereum"],tags:["blockchain","ethereum","oraclize","programming","smart contract","solidity","twitter"],github:"Ethereum-Twitter-Bounty"},unlisted:!1,prevItem:{title:"4 Things I Learned in 4 Years at Microsoft",permalink:"/blog/personal/4-things-i-learned-in-4-years-at-microsoft/"},nextItem:{title:"Building a Simple Sign-In Page with MSAL.js for Microsoft Identities",permalink:"/blog/aad/building-a-simple-sign-in-page-with-msal-js-for-microsoft-identities/"}},l={authorsImageUrls:[void 0]},h=[{value:"This post will show you how to use the Oraclize.it blockchain oracle to get and store Twitter posts for Ethereum smart contracts.",id:"this-post-will-show-you-how-to-use-the-oraclizeit-blockchain-oracle-to-get-and-store-twitter-posts-for-ethereum-smart-contracts",level:5},{value:"Ethereum Oracles",id:"ethereum-oracles",level:2},{value:"Twitter Post",id:"twitter-post",level:4},{value:"Oraclize Result",id:"oraclize-result",level:4},{value:"Twitter Post",id:"twitter-post-1",level:4},{value:"Oraclize Result",id:"oraclize-result-1",level:4}];function c(e){const t={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h4:"h4",h5:"h5",img:"img",p:"p",pre:"pre",strong:"strong",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h5,{id:"this-post-will-show-you-how-to-use-the-oraclizeit-blockchain-oracle-to-get-and-store-twitter-posts-for-ethereum-smart-contracts",children:"This post will show you how to use the Oraclize.it blockchain oracle to get and store Twitter posts for Ethereum smart contracts."}),"\n",(0,i.jsxs)(t.p,{children:["I recently created a end to end working dApp called ",(0,i.jsx)(t.a,{href:"https://github.com/shawntabrizi/Ethereum-Twitter-Bounty",children:'"Ethereum Twitter Bounty"'})," as the final project for the ",(0,i.jsx)(t.a,{href:"https://consensys.net/academy/2018developer/",children:"ConsenSys 2018 Developer Program"}),". In short, this dApp is a bounty contract which allows people to to pay or get paid to make specific Twitter posts. Imagine a decentralized marketing service where companies or individuals can allow normal users to virally market their product by sharing it with their peers on social networks like Twitter."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:n(8471).Z+"",width:"2526",height:"1014"})}),"\n",(0,i.jsx)(t.p,{children:"The dApp is broken up into two different contracts: one that fetches and stores Twitter posts on the blockchain and one that manages the bounties and validates the fulfillment conditions."}),"\n",(0,i.jsx)(t.p,{children:"Fulfillment in this contract is pretty straight-forward: we just need to check that the contents of one post is equal to the contents of another. But before we can even do that, we need to fetch the Twitter posts from the internet, and make them accessible to our blockchain contracts."}),"\n",(0,i.jsx)(t.p,{children:"That is what we will be going over in this blog post."}),"\n",(0,i.jsx)(t.h2,{id:"ethereum-oracles",children:"Ethereum Oracles"}),"\n",(0,i.jsxs)(t.p,{children:["Smart Contracts cannot natively talk to the outside world. Any data which you want a smart contract to access must be available on the blockchain. This is a really common problem that comes up when developing new dApps. Things like the current USD price of Ether, generating random numbers, and finding out the result of a real-world event involves the use of an ",(0,i.jsx)(t.strong,{children:"Oracle"}),": an external service which provides data to the blockchain."]}),"\n",(0,i.jsx)(t.p,{children:"Oracles are actually pretty easy to understand. They simply listen for requests coming from the blockchain for their services, get the data requested, and return it back to the blockchain in the form of a transaction. Anyone could build their own Oracle service and use it for their own personal needs, but that can be pretty complicated or cumbersome for a user who simply wants to create an Ethereum smart contract and not maintain their own cloud service. Additionally, if you are building a decentralized application which uses a custom made oracle, who is to trust that you are not manipulating the results? You start to lose all of the benefits of smart contracts once you delegate results and processes to the outside world."}),"\n",(0,i.jsxs)(t.p,{children:["This is where ",(0,i.jsx)(t.a,{href:"http://www.oraclize.it/",children:"Oraclize.it"})," comes in. They are an open platform for fetching external data, and providing cryptographic proofs of the results. This is particularly important because smart contracts are often in control of a lot of money, and when it comes to triggering contract code, users should be certain of the data flowing into the contract. Oraclize.it also provides all of the libraries and samples required to get started very quickly, which was super convenient for building my final project."]}),"\n",(0,i.jsxs)(t.p,{children:["However, ",(0,i.jsx)(t.a,{href:"http://docs.oraclize.it/",children:"their documentation"})," was a little lacking, specifically when it came to trying out my specific scenario! Here is what they wrote about fetching Twitter posts using their HTML parser:"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["HTML Parser: helper is useful for HTML scraping. The desired XPATH can be specified as argument of ",(0,i.jsx)(t.code,{children:"xpath(..)"})," as shown in the example:"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.code,{children:"html(https://twitter.com/oraclizeit/status/671316655893561344).xpath(//*[contains(@class, 'tweet-text')]/text())"})}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["You can actually try this out really quickly on their ",(0,i.jsx)(t.a,{href:"http://app.oraclize.it/home/test_query",children:"Test Query"})," page, and on their particular example, it does work okay... but as soon as you try another Twitter posts, things break down quickly. Here is an example of why this XPATH query is bad:"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:n(85134).Z+"",width:"1282",height:"578"})}),"\n",(0,i.jsxs)(t.p,{children:["You can see that it is capturing much more than just the original twitter post. All of the replies to the main post also contain the ",(0,i.jsx)(t.code,{children:"tweet-text"})," class which means that they get picked up by the Oraclize query. Not only does this cost a TON more gas to save to the blockchain, it adds a ton of data which will make it incredibly complicated to validate when a user makes a copy of the post for our scenario. Additionally, some parts of the post like #hashtags and @mentions do not show up, which are also really important for my scenario. So I had to hunt for a better way to parse these posts."]}),"\n",(0,i.jsx)(t.p,{children:"Ultimately, we just need to be more specific about where we grab the text from. Here is an upgraded XPATH query which selects only the main tweet text:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"html(https://twitter.com/<username>/status/<id>).xpath(//div[contains(@class, 'permalink-tweet-container')]//p[contains(@class, 'tweet-text')]//text())\n"})}),"\n",(0,i.jsx)(t.p,{children:"The results are much better, but still a little strange... Take a look at this example:"}),"\n",(0,i.jsx)(t.h4,{id:"twitter-post",children:"Twitter Post"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:n(63613).Z+"",width:"603",height:"488"})}),"\n",(0,i.jsx)(t.h4,{id:"oraclize-result",children:"Oraclize Result"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-json",children:'[\n  "This time, the vacuum tunnel will be a bit longer & SpaceX will provide some advance funding for student teams with most promising designs. Bonus award for all race pods that exceed half the speed of sound!",\n  "https://",\n  "twitter.com/hyperloop/stat",\n  "us/1032818998243520512",\n  "\\u00a0",\n  "\\u2026"\n]\n'})}),"\n",(0,i.jsx)(t.p,{children:"Note that we only get content from the main post now (yay!), but we still get this strange array format where things like the linked post are broken up into multiple pieces. To demonstrate more of the weird behavior, look at this other example:"}),"\n",(0,i.jsx)(t.h4,{id:"twitter-post-1",children:"Twitter Post"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:n(35330).Z+"",width:"608",height:"435"})}),"\n",(0,i.jsx)(t.h4,{id:"oraclize-result-1",children:"Oraclize Result"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-json",children:'[\n  "Amazing news! At ",\n  "#",\n  "HyperloopUPV",\n  " we will do our best to be on the top of the ",\n  "@",\n  "SpaceX",\n  " ",\n  "#",\n  "Hyperloop",\n  " competition this time! ",\n  "@",\n  "boringcompany",\n  " ",\n  "@",\n  "hyperloop",\n  "\\n",\n  "#",\n  "HyperloopSpain",\n  " ",\n  "@",\n  "UPV",\n  " ",\n  "#",\n  "SpaceX",\n  " ",\n  "#",\n  "ElonMusk",\n  " ",\n  "#",\n  "BreakaPod"\n]\n'})}),"\n",(0,i.jsx)(t.p,{children:"It is evident that things like #hashtags and @mentions, while present now, are broken up into different pieces. It is pretty easy to repair this on the front end by treating it as a JavaScript array, and then joining the parts:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:'JSON.parse(result).join("");\n\n/*\n"Amazing news! At #HyperloopUPV we will do our best to be on the top of the @SpaceX #Hyperloop competition this time! @boringcompany @hyperloop\n#HyperloopSpain @UPV #SpaceX #ElonMusk #BreakaPod"\n*/\n'})}),"\n",(0,i.jsx)(t.p,{children:"This final result is perfect, and accurately represents what we want. Unfortunately, on the blockchain, the data is still in this array format, and there is no clean, low gas way to change it that I am aware of."}),"\n",(0,i.jsx)(t.p,{children:"For my purposes, this can cause some validation issues if there are white-space differences between what the user posts and what the fulfiller used to create their bounty. To avoid this, my suggestion is to keep the posts relatively simple. This will also reduce the amount of gas required to store the post on the blockchain."}),"\n",(0,i.jsxs)(t.p,{children:['The final contract code for my "Twitter Oracle" can be found ',(0,i.jsx)(t.a,{href:"https://github.com/shawntabrizi/Ethereum-Twitter-Bounty/blob/master/twitter-bounty/contracts/TwitterOracle.sol",children:"here"}),". Here is a relevant snippet:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'/// @notice This function initiates the oraclize process for a Twitter post\n/// @dev This contract needs ether to be able to call the oracle, which is why this function is also payable\n/// @param _postId The twitter post to fetch with the oracle. Expecting "<user>/status/<id>"\nfunction oraclizeTweet(string _postId)\npublic\npayable\nwhenNotPaused\n{\n    // Check if we have enough remaining funds\n    if (oraclize_getPrice("URL") > address(this).balance) {\n        emit LogInfo("Oraclize query was NOT sent, please add some ETH to cover for the query fee");\n    } else {\n        emit LogInfo("Oraclize query was sent, standing by for the answer..");\n        // Using XPath to to fetch the right element in the JSON response\n        string memory query = string(abi.encodePacked("html(https://twitter.com/", _postId, ").xpath(//div[contains(@class, \'permalink-tweet-container\')]//p[contains(@class, \'tweet-text\')]//text())"));\n\n        bytes32 queryId = oraclize_query("URL", query, 6721975);\n        queryToPost[queryId] = _postId;\n    }\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["In this code, you can see I have specified a custom gas limit which is extremely high. The default gas limit for the ",(0,i.jsx)(t.code,{children:"oraclize_query"}),' is 200,000 gas, which was causing "out of gas" errors when trying to store the data in the smart contract. I changed the value to be the gas limit for ganache-cli (6,721,975 gas), which is probably not very smart for production, but I did not really invest time into thinking about what a reasonable gas limit would be, and I just wanted to make sure not to run into errors when avoidable.']}),"\n",(0,i.jsxs)(t.p,{children:["Take note of another key implementation detail. I get a ",(0,i.jsx)(t.code,{children:"queryId"})," as a result of ",(0,i.jsx)(t.code,{children:"oraclize_query"}),". Then I store this value in a mapping, where the value is the Twitter URL (",(0,i.jsx)(t.code,{children:"postId"}),") that is being oraclized. This is important because the oraclization process is asynchronous, so when I get a result back from Oraclize.it, I need to know which post the text is for. I then check the mapping I created for the result with a matching ",(0,i.jsx)(t.code,{children:"queryId"}),", fetch the ",(0,i.jsx)(t.code,{children:"postId"}),", and then create a mapping using the ",(0,i.jsx)(t.code,{children:"postId"})," as the key, and the resulting post text as the value. A little tricky, but totally works! :)"]}),"\n",(0,i.jsxs)(t.p,{children:["Anyway, I hope you learned something from my little exploration into oraclizing Twitter posts for Ethereum dApp development. Try out my app locally by following the instructions on the ",(0,i.jsx)(t.a,{href:"https://github.com/shawntabrizi/Ethereum-Twitter-Bounty",children:"GitHub page"}),". If you know of a better way to solve this problem, let me know! Otherwise, if you enjoyed this content, feel free to take a look at my ",(0,i.jsx)(t.a,{href:"https://shawntabrizi.com/donate/",children:"donations page"}),"."]})]})}function d(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},85134:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/img_5b833f04ca84f-2f03ef51a5128490d6696442a01892e3.png"},63613:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/img_5b834588d4946-3719e2710536173ac51c9e73799e77db.png"},35330:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/img_5b83469aa1592-f5cb81534c012b3e5659ab8c978df968.png"},8471:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/img_5b838a8f8a429-8c53abe431d3d123735d75f01c759206.png"},11151:(e,t,n)=>{n.d(t,{Z:()=>s,a:()=>r});var i=n(67294);const o={},a=i.createContext(o);function r(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);