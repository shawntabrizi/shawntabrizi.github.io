---
title: Querying Substrate Storage via RPC
date: 2019-07-28T16:14:03-08:00
author: Shawn Tabrizi
layout: post
permalink: /substrate/querying-substrate-storage-via-rpc/
categories:
  - Substrate
tags:
  - runtime
  - module
  - rpc
  - metadata
  - storage
github: sudo-contract
---

##### In this post, we will investigate how you can interact with the Substrate RPC endpoint in order to read storage items in your Substrate runtime.

Most of the posts I have written about Substrate so far have showed you how easy it is to build custom blockchains with this next generation framework. However, there is an entirely parellel set of development and tools needed to enable users to easily interact with these new blockchain systems.

## Available RPC Methods

The available RPC methods that Substrate allows are documented as part of the [Polkadot-JS docs](https://polkadot.js.org/api/METHODS_RPC.html).

There are 4 category of RPC methods:

* [`author`](https://polkadot.js.org/api/METHODS_RPC.html#author)
* [`chain`](https://polkadot.js.org/api/METHODS_RPC.html#chain)
* [`state`](https://polkadot.js.org/api/METHODS_RPC.html#state)
* [`system`](https://polkadot.js.org/api/METHODS_RPC.html#system)

For this post, we ultimately want to call the `getStorage` method in `state`:

```
getStorage(key: StorageKey, block?: Hash): StorageData

summary: Retrieves the storage for a key
```

> Note that specifying a `block` here is optional. By default, it will query the latest block.

However, to start simple, we will query the Metadata endpoint for our Substrate node, which requires no information beyond the method name. The actual RPC method name is generated by combining the category with the documented function name, like so:

* `state_getStorage`
* `state_getMetadata`

## Substrate RPC Endpoint

To actually call these methods, you need a Substrate RPC endpoint. When you start a local Substrate node, two endpoints are made available to you:

* HTTP Endpoint: http://localhost:9933/
* Websocket Endpoint: ws://localhost:9944/

Most of the Substrate front-end libraries and tools use the more powerful WebSocket endpoint to interact with the blockchain. Through WebSockets, you can subscribe to various items, like events, and receive push notifications whenever changes in your blockchain occur.

For the purposes of this post, we will keep things simple and use the HTTP endpoint to make JSON-RPC queries to our blockchain.

### Accessing the Public RPC Endpoint

If you do not want to set up a local node just to test storage queries, the Substrate testnet exposes a JSON-RPC endpoint at `https://substrate-rpc.parity.io/` that support SSL connections from POST requests.

Unfortunately the latest [OAS3](https://swagger.io/docs/specification/paths-and-operations/) does not allow multiple POST methods for the same "root" API endpoint path.

To get around this, Parity has authored the Substrate testnet with the endpoint name for each POST request matching the name of the associated RPC method. This means in order for your RPC call to work, you need to target an endpoint like:

```
https://substrate-rpc.parity.io/state_getMetadata
```

Here is an example:

```bash
// Failure
$ curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method": "state_getMetadata"}' https://substrate-rpc.parity.io

> WebSocket Protocol Error: Unable to parse WebSocket key.

// Success
$ curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method": "state_getMetadata"}' https://substrate-rpc.parity.io/state_getMetadata

> {"jsonrpc":"2.0","result":"0x6d65746103441873797374656d1853797374656d012c304163636f756e744e6f6e636501013054...
```

You should be able to run these commands in your terminal and get similar results. A little crazy, but needed to get it to work.

## Substrate Encoding

So now we have seen that a basic RPC call to get the metadata from Substrate is successful. However, you will notice the result is a _large_ hex value, which really isn't that helpful...

What we haven't touched on yet are the various encoding mechanisms used by Substrate to both optimize serialization of data, but also provide safeties to the blockchain system.

### Naive Text Decoding

If we try to naively decode the hex returned from the metadata endpoint, we get something like:

```javascript
function naive_decode_metadata(metadata) {
  return new TextDecoder().decode(utils.hexToU8a(metadata));
}

naive_decode_metadata("0x6d65746103441873797374656d1853797374656d012c304163636f756e744e6f6e636501013054")

> "metaDsystemSystem,0AccountNonce0T"
```

There is real data in there! However it is not really well formed, and some things look weird...

To correctly parse the metadata, you will need to become familiar with is [Parity's SCALE codec](https://github.com/paritytech/parity-scale-codec):

> SCALE is a light-weight format which allows encoding (and decoding) which makes it highly suitable for resource-constrained execution environments like blockchain runtimes and low-power, low-memory devices.

Parity uses SCALE for a number of reasons. [Gav](https://github.com/gavofyork) mentioned that:
* It does not use Rust STD, and thus can compile to Wasm.
* On little-endian hardware, it is zero-copy and uses next to no memory for elementary numeric types.
* It is built to have great support in Rust for deriving codec logic for new types.
* 
basically, it's as thin as it's possible to get.