---
title: Querying Substrate Storage via RPC
date: 2019-07-28T16:14:03-08:00
author: Shawn Tabrizi
layout: post
permalink: /substrate/querying-substrate-storage-via-rpc/
categories:
  - Substrate
tags:
  - runtime
  - module
  - rpc
  - metadata
  - storage
github: sudo-contract
---

##### In this post, we will investigate how you can interact with the Substrate RPC endpoint in order to read storage items in your Substrate runtime.

Most of the posts I have written about Substrate so far have showed you how easy it is to build custom blockchains with this next generation framework. However, there is an entirely parellel set of development and tools needed to enable users to easily interact with these new blockchain systems.

## Available RPC Methods

The available RPC methods that Substrate allows are documented as part of the [Polkadot-JS docs](https://polkadot.js.org/api/METHODS_RPC.html).

There are 4 category of RPC methods:

* [`author`](https://polkadot.js.org/api/METHODS_RPC.html#author)
* [`chain`](https://polkadot.js.org/api/METHODS_RPC.html#chain)
* [`state`](https://polkadot.js.org/api/METHODS_RPC.html#state)
* [`system`](https://polkadot.js.org/api/METHODS_RPC.html#system)

For this post, we ultimately want to call the `getStorage` method in `state`:

```
getStorage(key: StorageKey, block?: Hash): StorageData

summary: Retrieves the storage for a key
```

> Note that specifying a `block` here is optional. By default, it will query the latest block.

However, to start simple, we will query the Metadata endpoint for our Substrate node, which requires no information beyond the method name. The actual RPC method name is generated by combining the category with the documented function name, like so:

* `state_getStorage`
* `state_getMetadata`

## Substrate RPC Endpoint

To actually call these methods, you need a Substrate RPC endpoint. When you start a local Substrate node, two endpoints are made available to you:

* HTTP Endpoint: http://localhost:9933/
* Websocket Endpoint: ws://localhost:9944/

Most of the Substrate front-end libraries and tools use the more powerful WebSocket endpoint to interact with the blockchain. Through WebSockets, you can subscribe to various items, like events, and receive push notifications whenever changes in your blockchain occur.

For the purposes of this post, we will keep things simple and use the HTTP endpoint to make JSON-RPC queries to our blockchain.

### Accessing the Public RPC Endpoint

If you do not want to set up a local node just to test storage queries, the Substrate testnet exposes a JSON-RPC endpoint at `https://substrate-rpc.parity.io/` that support SSL connections from POST requests.

Unfortunately the latest [OAS3](https://swagger.io/docs/specification/paths-and-operations/) does not allow multiple POST methods for the same "root" API endpoint path.

To get around this, Parity has authored the Substrate testnet with the endpoint name for each POST request matching the name of the associated RPC method. This means in order for your RPC call to work, you need to target an endpoint like:

```
https://substrate-rpc.parity.io/state_getMetadata
```

Here is an example:

```bash
// Failure
$ curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method": "state_getMetadata"}' https://substrate-rpc.parity.io

> WebSocket Protocol Error: Unable to parse WebSocket key.

// Success
$ curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method": "state_getMetadata"}' https://substrate-rpc.parity.io/state_getMetadata

> {"jsonrpc":"2.0","result":"0x6d65746103441873797374656d1853797374656d012c304163636f756e744e6f6e636501013054...
```

You should be able to run these commands in your terminal and get similar results. A little crazy, but needed to get it to work.

## Substrate Encoding

So now we have seen that a basic RPC call to get the metadata from Substrate is successful. However, you will notice the result is a _large_ hex value, which really isn't that helpful...

What we haven't touched on yet are the various encoding mechanisms used by Substrate to both optimize serialization of data, but also provide safeties to the blockchain system.

### SCALE Codec

If we try to naively decode the hex returned from the metadata endpoint, we get something like:

```javascript
function naive_decode_metadata(metadata) {
  return new TextDecoder().decode(utils.hexToU8a(metadata));
}

naive_decode_metadata("0x6d65746103441873797374656d1853797374656d012c304163636f756e744e6f6e636501013054...")

> "metaDsystemSystem,0AccountNonce0T..."
```

There is real data in there! However it is not really well formed, and some things look weird...

To correctly parse the metadata, you will need to become familiar with is [Parity's SCALE codec](https://github.com/paritytech/parity-scale-codec):

> SCALE is a light-weight format which allows encoding (and decoding) which makes it highly suitable for resource-constrained execution environments like blockchain runtimes and low-power, low-memory devices.

Parity uses SCALE for a number of reasons. [Gav](https://github.com/gavofyork) mentioned that:

* It does not use Rust STD, and thus can compile to Wasm.
* On little-endian hardware, it is zero-copy and uses next to no memory for elementary numeric types.
* It is built to have great support in Rust for deriving codec logic for new types.
* It is about as thin and lightweight as it can be.

Using the SCALE codec and parsing the Substrate metadata could be it's own blog post, so I will not go any deeper here. I just wanted to point out the main encoding scheme used by Substrate, and which shows up in the examples we have done so far.

### Storage Keys

For our goal, what we really want to learn is how to generate the storage keys for our various runtime storage items.

Substrate has a single key-value database for powering the entire blockchain framework. From this minimal data structure, additional abstractions can be constructed such as a [Merkle Patricia tree ("trie")](https://github.com/paritytech/trie) that is ultimately used throughout Substrate.

However, at a base level, to gain access to any runtime storage item, you simply need to know it's key for the core key-value database. To prevent key collisions, a special schema is used for this purpose:

* For storage values:

	```
	xxhash128("ModuleName" + " " + "StorageItem")
	```

* For storage maps:

	```
	blake256hash("ModuleName" + " " + "StorageItem" + scale("StorageItemKey"))
	```

* For storage double maps:

	```
	blake256hash("ModuleName" + " " + "StorageItem" + scale("FirstStorageItemKey")) + blake256hash(scale("SecondStorageItemKey"))
	```

This may not make a lot of sense right now, but we will do some practical examples below.

> **Historical Info:** Note that for storage values we use the [XXHash](https://github.com/shepmaster/twox-hash) (a non-crypographic hash algorithm), whereas for storage maps we use [Blake-256](https://en.wikipedia.org/wiki/BLAKE_(hash_function)). It used to be that XXHash was used in both situations, however [there were concerns](https://github.com/paritytech/substrate/issues/1868) about attacks where external users could manipulate storage maps to generate storage keys to collide with one another. The same issue does not arise for storage values because the seed used in the hash is not manipulatable by external parties. XXHash is an order of magnitude faster in real world situations, so we continue to use it when possible, but for added cryptographic security guarantees, we need to use `Blake256`.

## Querying Runtime Storage

We are almost to the finish line. Now that you know the different storage key encoding patterns, we can try to construct and query the runtime storage for a Substrate chain. Since you will need to use some cryptographic hash functions to try this yourself, go to:

	https://www.shawntabrizi.com/substrate-rpc-examples/

This page will load utility functions under `utils.*`, `util_crypto.*`, and `keyring.*` which you can access from your browser console. These come from the [polkadot-js/common](https://polkadot.js.org/common/) and will give you access to the hash functions like `util_crypto.xxhashAsHex` or `util_crypto.blake2AsHex`.

Let's start with a simple storage value, for instance getting the [Sudo user](https://substrate.dev/rustdocs/v1.0/srml_sudo/index.html) for a Substrate chain. The storage item which holds the `AccountId` for Sudo is named `Key`.

Thus we would do the following:

```javascript
util_crypto.xxhashAsHex("Sudo Key", 128)

> "0x50a63a871aced22e88ee6466fe5aa5d9"
```

Now we can form an RPC request using this value as the `params` when calling the `state_getStorage` endpoint:

```bash
$ curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method": "state_getStorage", "params": ["0x50a63a871aced22e88ee6466fe5aa5d9"]}' https://substrate-rpc.parity.io/state_getStorage

> {"jsonrpc":"2.0","result":"0xc224ccba63292331623bbf06a55f46607824c2580071a80a17c53cab2f999e2f","id":1}
```

Success!


