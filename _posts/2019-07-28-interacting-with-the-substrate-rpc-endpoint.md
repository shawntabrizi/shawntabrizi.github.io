---
title: Querying Substrate Storage via RPC
date: 2019-07-28T16:14:03-08:00
author: Shawn Tabrizi
layout: post
permalink: /substrate/querying-substrate-storage-via-rpc/
categories:
  - Substrate
tags:
  - runtime
  - module
  - rpc
  - metadata
  - storage
github: sudo-contract
---

##### In this post, we will investigate how you can interact with the Substrate RPC endpoint in order to read storage items in your Substrate runtime.

Most of the posts I have written about Substrate so far have showed you how easy it is to build custom blockchains with this next generation framework. However, there is an entirely parellel set of development and tools needed to enable users to easily interact with these new blockchain systems.

## Available RPC Methods

The available RPC methods that Substrate allows are documented as part of the [Polkadot-JS docs](https://polkadot.js.org/api/METHODS_RPC.html).

There are 4 category of RPC methods:

* [`author`](https://polkadot.js.org/api/METHODS_RPC.html#author)
* [`chain`](https://polkadot.js.org/api/METHODS_RPC.html#chain)
* [`state`](https://polkadot.js.org/api/METHODS_RPC.html#state)
* [`system`](https://polkadot.js.org/api/METHODS_RPC.html#system)

For this post, we ultimately want to call the `getStorage` method in `state`:

```
getStorage(key: StorageKey, block?: Hash): StorageData

summary: Retrieves the storage for a key
```

> Note that specifying a `block` here is optional. By default, it will query the latest block.

However, to start simple, we will query the Metadata endpoint for our Substrate node, which requires no information beyond the method name. The actual RPC method name is generated by combining the category with the documented function name, like so:

* `state_getStorage`
* `state_getMetadata`

## Substrate RPC Endpoint

To actually call these methods, you need a Substrate RPC endpoint. When you start a local Substrate node, two endpoints are made available to you:

* HTTP Endpoint: http://localhost:9933/
* Websocket Endpoint: ws://localhost:9944/

Most of the Substrate front-end libraries and tools use the more powerful WebSocket endpoint to interact with the blockchain. Through WebSockets, you can subscribe to various items, like events, and receive push notifications whenever changes in your blockchain occur.

For the purposes of this post, we will keep things simple and use the HTTP endpoint to make JSON-RPC queries to our blockchain.

### Accessing the Public RPC Endpoint

If you do not want to set up a local node just to test storage queries, the Substrate testnet exposes a JSON-RPC endpoint at `https://substrate-rpc.parity.io/` that support SSL connections from POST requests.

Unfortunately the latest [OAS3](https://swagger.io/docs/specification/paths-and-operations/) does not allow multiple POST methods for the same "root" API endpoint path.

To get around this, Parity has authored the Substrate testnet with the endpoint name for each POST request matching the name of the associated RPC method. This means in order for your RPC call to work, you need to target an endpoint like:

```
https://substrate-rpc.parity.io/state_getMetadata
```

Here is an example:

```bash
// Failure
$ curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method": "state_getMetadata"}' https://substrate-rpc.parity.io

> WebSocket Protocol Error: Unable to parse WebSocket key.

// Success
$ curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method": "state_getMetadata"}' https://substrate-rpc.parity.io/state_getMetadata

> {"jsonrpc":"2.0","result":"0x6d65746103441873797374656d1853797374656d012c304163636f756e744e6f6e636501013054...
```

You should be able to run these commands in your terminal and get similar results. A little crazy, but needed to get it to work.

## Substrate Encoding

So now we have seen that a basic RPC call to get the metadata from Substrate is successful. However, you will notice the result is a _large_ hex value, which really isn't that helpful...

What we haven't touched on yet are the various encoding mechanisms used by Substrate to both optimize serialization of data, but also provide safeties to the blockchain system.

### SCALE Codec

If we try to naively decode the hex returned from the metadata endpoint, we get something like:

```javascript
function naive_decode_metadata(metadata) {
  return new TextDecoder().decode(utils.hexToU8a(metadata));
}

naive_decode_metadata("0x6d65746103441873797374656d1853797374656d012c304163636f756e744e6f6e636501013054...")

> "metaDsystemSystem,0AccountNonce0T..."
```

There is real data in there! However it is not really well formed, and some things look weird...

To correctly parse the metadata, you will need to become familiar with is [Parity's SCALE codec](https://github.com/paritytech/parity-scale-codec):

> SCALE is a light-weight format which allows encoding (and decoding) which makes it highly suitable for resource-constrained execution environments like blockchain runtimes and low-power, low-memory devices.

Parity uses SCALE for a number of reasons. [Gav](https://github.com/gavofyork) mentioned that:

* It does not use Rust STD, and thus can compile to Wasm.
* On little-endian hardware, it is zero-copy and uses next to no memory for elementary numeric types.
* It is built to have great support in Rust for deriving codec logic for new types.
* It is about as thin and lightweight as it can be.

Using the SCALE codec and parsing the Substrate metadata could be it's own blog post, so I will not go any deeper here. I just wanted to point out the main encoding scheme used by Substrate, and which shows up in the examples we have done so far.

### Storage Keys

For our goal, what we really want to learn is how to generate the storage keys for our various runtime storage items.

Substrate has a single key-value database for powering the entire blockchain framework. From this minimal data structure, additional abstractions can be constructed such as a [Merkle Patricia tree ("trie")](https://github.com/paritytech/trie) that is ultimately used throughout Substrate.

However, at a base level, to gain access to any runtime storage item, you simply need to know it's key for the core key-value database. To prevent key collisions, a special schema is used for this purpose:

* For storage values:

	```
	xxhash128(bytes("ModuleName" + " " + "StorageItem"))
	```

* For storage maps:

	```
	blake256hash(bytes("ModuleName" + " " + "StorageItem") + bytes(scale("StorageItemKey")))
	```

* For storage double maps:

	```
	blake256hash(bytes("ModuleName" + " " + "StorageItem") + bytes(scale("FirstStorageItemKey"))) + blake256hash(bytes(scale("SecondStorageItemKey")))
	```

This may not make a lot of sense right now, but we will do some practical examples below.

> **Historical Info:** Note that for storage values we use the [XXHash](https://github.com/shepmaster/twox-hash) (a non-crypographic hash algorithm), whereas for storage maps we use [Blake-256](https://en.wikipedia.org/wiki/BLAKE_(hash_function)). It used to be that XXHash was used in both situations, however [there were concerns](https://github.com/paritytech/substrate/issues/1868) about attacks where external users could manipulate storage maps to generate storage keys to collide with one another. The same issue does not arise for storage values because the seed used in the hash is not manipulatable by external parties. XXHash is an order of magnitude faster in real world situations, so we continue to use it when possible, but for added cryptographic security guarantees, we need to use `Blake256`.

## Querying Runtime Storage

We are almost to the finish line. Now that you know the different storage key encoding patterns, we can try to construct and query the runtime storage for a Substrate chain. Since you will need to use some cryptographic hash functions to try this yourself, go to:

	https://www.shawntabrizi.com/substrate-rpc-examples/

This page will load utility functions under `utils.*`, `util_crypto.*`, and `keyring.*` which you can access from your browser console. These come from the [polkadot-js/common](https://polkadot.js.org/common/) and will give you access to the hash functions like `util_crypto.xxhashAsHex` or `util_crypto.blake2AsHex`.

### Storage Value Query

Let's start with a simple storage value, for instance getting the [Sudo user](https://substrate.dev/rustdocs/v1.0/srml_sudo/index.html) for a Substrate chain. The module name is `Sudo` and the storage item which holds the `AccountId` is named `Key`.

Thus we would do the following:

```javascript
util_crypto.xxhashAsHex(utils.stringToU8a("Sudo Key"), 128)

> "0x50a63a871aced22e88ee6466fe5aa5d9"
```

> **Note:** Note that we specified to use the 128 bit version of XXHash.

Now we can form an RPC request using this value as the `params` when calling the `state_getStorage` endpoint:

```bash
$ curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method": "state_getStorage", "params": ["0x50a63a871aced22e88ee6466fe5aa5d9"]}' https://substrate-rpc.parity.io/state_getStorage

> {"jsonrpc":"2.0","result":"0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d","id":1}
```

Success! The result here is the SCALE encoded AccountID of the Sudo user:

```
keyring.encodeAddress("0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d")

> "5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY"
```

This is the familiar `Alice` account which we would expect, and matches what we get using the [Polkadot-JS UI](https://polkadot.js.org/apps/#/chainstate) configured to this same endpoint (or any `--dev` chain):

![Sudo Key for the Substrate `--dev` node](/assets/images/sudo-key-dev-node.png)

### Storage Map Query

As a final challenge, we will look to query a storage map like the balance of an account. The module name is `Balances` and the storage item we are interested in is named `FreeBalance`. They mapping for this storage item is from `AccountId -> Balance`, so the storage item key we want to use is an `AccountId`.

Remember we need to use Blake-256 and a slightly different pattern for generating the key for these kinds of storage items:


```javascript
util_crypto.blake2AsHex([...utils.stringToU8a("Balances FreeBalance"), ...utils.hexToU8a("0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d")], 256)

> "0x7f864e18e3dd8b58386310d2fe0919eef27c6e558564b7f67f22d99d20f587bb"
```

Just like before, we can form an RPC request using this value as the `params`:

```bash
$ curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method": "state_getStorage", "params": ["0x7f864e18e3dd8b58386310d2fe0919eef27c6e558564b7f67f22d99d20f587bb"]}' http://dev-node.substrate.dev:9933

{"jsonrpc":"2.0","result":"0x0000a0dec5adc9353600000000000000","id":1}
```

The result here is now a SCALE encoded version of the `Balance` type, which is a basic u64 and thus trivially decodable:

```javascript
utils.hexToBn("0x0000a0dec5adc9353600000000000000").toString()

> "3262835367303712780689496311070720"
```

Woohoo!

## Next Steps

If you made it this far, you probably have come to the same conclusion as me, which is that interacting with the Substrate RPC is not trivial. Substrate is optimized for performance, bandwidth, and execution, which leaves tasks like encoding and decoding of transactions, queries, etc... to the outside world. 

That being said, once you are able to walk through these examples step by step, I think it becomes easier to understand what is going on, and even reproduce this logic on other platforms and languages.

I have started a project called [Substrate RPC Examples](https://github.com/shawntabrizi/substrate-rpc-examples) which I linked to earlier in this post. The idea of this project is to provide some easy to read, minimal "library magic" examples of interacting with the Substrate RPC. So far, I have only used the tools available in `utils`, `util_crypto`, and `keyring`, and ideally this can be reduced by introducing a few hand written functions.

The two samples I have described in this blog post (getting metadata, querying storage) are implemented, and I hope to also add to it a balance transfer. If you have any good ideas or examples that you would want to share with the world, feel free to open a [PR](https://github.com/shawntabrizi/substrate-rpc-examples/pulls).

I think the next follow up from this post should be a deep dive into the SCALE codec and how you can turn the Metadata you receive from a Substrate node into valid JSON.

As always, if you are enjoying the content I have produced, take a look at my [donations page](https://shawntabrizi.com/donate/) to see how you can continue to support me.
